commit a3b6f2b76e9e879e6549f46275818eec75766612
Author: Twisted Playground <twistedumbrella@gmail.com>
Date:   Tue Dec 6 17:00:14 2011 -0500

    OpenGL Patch
    
    Change-Id: I8191c7024bf542a310e7dbd4033efaa3c8e42066

diff --git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp
index d816e7c..1147499 100644
--- a/cmds/bootanimation/BootAnimation.cpp
+++ b/cmds/bootanimation/BootAnimation.cpp
@@ -218,15 +218,20 @@ status_t BootAnimation::readyToRun() {
     SurfaceComposerClient::closeGlobalTransaction();
 
     sp<Surface> s = control->getSurface();
-
     // initialize opengl and egl
     const EGLint attribs[] = {
+/* Hack to fix BootAnimation
             EGL_RED_SIZE,   8,
             EGL_GREEN_SIZE, 8,
             EGL_BLUE_SIZE,  8,
+*/
+            EGL_RED_SIZE,   5,
+            EGL_GREEN_SIZE, 6,
+            EGL_BLUE_SIZE,  5,
             EGL_DEPTH_SIZE, 0,
             EGL_NONE
     };
+
     EGLint w, h, dummy;
     EGLint numConfigs;
     EGLConfig config;
@@ -343,11 +348,11 @@ bool BootAnimation::android()
         glEnable(GL_BLEND);
         glBindTexture(GL_TEXTURE_2D, mAndroid[0].name);
         glDrawTexiOES(xc, yc, 0, mAndroid[0].w, mAndroid[0].h);
-
+/* Hack to fix BootAnimation
         EGLBoolean res = eglSwapBuffers(mDisplay, mSurface);
         if (res == EGL_FALSE)
             break;
-
+*/
         // 12fps: don't animate too fast to preserve CPU
         const nsecs_t sleepTime = 83333 - ns2us(systemTime() - now);
         if (sleepTime > 0)
diff --git a/opengl/include/GLES/glext.h b/opengl/include/GLES/glext.h
index 05ac93e..89ea3b9 100644
--- a/opengl/include/GLES/glext.h
+++ b/opengl/include/GLES/glext.h
@@ -213,7 +213,8 @@ typedef void* GLeglImageOES;
 
 /* GL_OES_EGL_image_external */
 #ifndef GL_OES_EGL_image_external
-#ifdef MISSING_EGL_EXTERNAL_IMAGE
+# ifdef BOARD_GL_OES_EGL_IMG_EXTERNAL_HACK
+// Use GL_TEXTURE_2D instead
 #define GL_TEXTURE_EXTERNAL_OES                                 0x0DE1
 #else
 #define GL_TEXTURE_EXTERNAL_OES                                 0x8D65
diff --git a/opengl/include/GLES2/gl2ext.h b/opengl/include/GLES2/gl2ext.h
index 8135f4a..8a57c9e 100644
--- a/opengl/include/GLES2/gl2ext.h
+++ b/opengl/include/GLES2/gl2ext.h
@@ -148,7 +148,7 @@ typedef void* GLeglImageOES;
 
 /* GL_OES_EGL_image_external */
 #ifndef GL_OES_EGL_image_external
-#ifdef MISSING_EGL_EXTERNAL_IMAGE
+#ifdef BOARD_GL_OES_EGL_IMG_EXTERNAL_HACK
 #define GL_TEXTURE_EXTERNAL_OES                                 0x0DE1
 #else
 #define GL_TEXTURE_EXTERNAL_OES                                 0x8D65
diff --git a/opengl/libagl/state.cpp b/opengl/libagl/state.cpp
index 7321182..8c9e6b5 100644
--- a/opengl/libagl/state.cpp
+++ b/opengl/libagl/state.cpp
@@ -191,12 +191,11 @@ static void enable_disable(ogles_context_t* c, GLenum cap, int enabled)
         // these need to fall through into the rasterizer
         c->rasterizer.procs.enableDisable(c, cap, enabled);
         break;
-#ifndef MISSING_EGL_EXTERNAL_IMAGE
+#ifndef BOARD_GL_OES_EGL_IMG_EXTERNAL_HACK
     case GL_TEXTURE_EXTERNAL_OES:
         c->rasterizer.procs.enableDisable(c, GL_TEXTURE_2D, enabled);
         break;
 #endif
-
     case GL_MULTISAMPLE:
     case GL_SAMPLE_ALPHA_TO_COVERAGE:
     case GL_SAMPLE_ALPHA_TO_ONE:
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 1f9ce68..4eb0cab 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -942,6 +942,13 @@ EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface draw)
         return setError(EGL_BAD_SURFACE, EGL_FALSE);
 
     egl_surface_t const * const s = get_surface(draw);
+// Hack to enable OpenGL
+#ifdef BOARD_GL_OES_EGL_IMG_EXTERNAL_HACK
+    s->cnx->egl.eglSwapBuffers(dp->disp[s->impl].dpy, s->surface);
+	return EGL_TRUE;
+#else
+    return s->cnx->egl.eglSwapBuffers(dp->disp[s->impl].dpy, s->surface);
+#endif 
     return s->cnx->egl.eglSwapBuffers(dp->disp[s->impl].dpy, s->surface);
 }
 
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
index 2353c0c..022a155 100644
--- a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -21,6 +21,8 @@
 
 #include <cutils/properties.h>
 
+#define LOG_NDEBUG 0
+
 #include <utils/RefBase.h>
 #include <utils/Log.h>
 
@@ -111,15 +113,62 @@ static status_t selectConfigForPixelFormat(
     eglGetConfigs(dpy, NULL, 0, &numConfigs);
     EGLConfig* const configs = new EGLConfig[numConfigs];
     eglChooseConfig(dpy, attrs, configs, numConfigs, &n);
+    
+    EGLint t,r,g,b,a,d,v,rd,ndx=0;
+    
+    LOGI("Wanted surface format = %x", format);
+    int alpha = 8, green = 8;
+    switch (format) {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+            break;
+        case HAL_PIXEL_FORMAT_RGBA_5551:
+            alpha = 1;
+            green = 5;
+            break;
+        case HAL_PIXEL_FORMAT_RGBA_4444:
+            alpha = 4;
+            green = 4;
+            break;
+        case HAL_PIXEL_FORMAT_RGB_565:
+            green = 6;
+            alpha = 0;
+            break;
+    }
+
     for (int i=0 ; i<n ; i++) {
+        
         EGLint nativeVisualId = 0;
         eglGetConfigAttrib(dpy, configs[i], EGL_NATIVE_VISUAL_ID, &nativeVisualId);
-        if (nativeVisualId>0 && format == nativeVisualId) {
+        eglGetConfigAttrib(dpy, configs[i], EGL_SURFACE_TYPE, &t);
+        eglGetConfigAttrib(dpy, configs[i], EGL_ALPHA_SIZE, &a);
+        eglGetConfigAttrib(dpy, configs[i], EGL_GREEN_SIZE, &g);
+        
+        if (a == alpha && g == green) {
+//        if (nativeVisualId>0 && format == nativeVisualId) {
             *outConfig = configs[i];
             delete [] configs;
             return NO_ERROR;
         }
+        
+        // Display ignored egl configs
+        eglGetConfigAttrib(dpy, configs[i], EGL_RED_SIZE,   &r);
+        eglGetConfigAttrib(dpy, configs[i], EGL_BLUE_SIZE,  &b);
+        eglGetConfigAttrib(dpy, configs[i], EGL_DEPTH_SIZE, &d); //0 0x10 0x18
+        
+        //EGL_LEVEL all are 0
+        //EGL_SURFACE_TYPE all 0x7 (1+2+4)
+        //eglGetConfigAttrib(dpy, configs[i], EGL_TRANSPARENT_TYPE, &t); // all are same
+        
+        eglGetConfigAttrib(dpy, configs[i], EGL_NATIVE_VISUAL_ID, &v); // 0(various) 1(8888) 2(8880) 4(565)
+        eglGetConfigAttrib(dpy, configs[i], EGL_NATIVE_RENDERABLE, &rd);
+        
+        if (r==0) continue;
+        
+        LOGI("Ignore config %d: RGBA_%d%d%d%d Depth %x Native ID=%x(%x)", i, r,g,b,a, d,v,rd);
     }
+    
     delete [] configs;
     return NAME_NOT_FOUND;
 }
@@ -184,12 +233,8 @@ void DisplayHardware::init(uint32_t dpy)
     eglGetConfigs(display, NULL, 0, &numConfigs);
 
     EGLConfig config = NULL;
-#ifdef FORCE_EGL_CONFIG
-    config = (EGLConfig)FORCE_EGL_CONFIG;
-#else
     err = selectConfigForPixelFormat(display, attribs, format, &config);
     LOGE_IF(err, "couldn't find an EGLConfig matching the screen format");
-#endif
     
     EGLint r,g,b,a;
     eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &r);
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 317cc3b..51270a6 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -578,12 +578,8 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
         // need a hardware-protected path to external video sink
         usage |= GraphicBuffer::USAGE_PROTECTED;
     }
-#ifdef MISSING_GRALLOC_BUFFERS
+    //usage |= GraphicBuffer::USAGE_HW_COMPOSER;
     usage |= GraphicBuffer::USAGE_HW_TEXTURE;
-#else
-    usage |= GraphicBuffer::USAGE_HW_COMPOSER;
-#endif
-
     return usage;
 }
 
