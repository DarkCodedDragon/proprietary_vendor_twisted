commit be0834211d8c1e159ea59460e3025dfe14dd6f70
Author: Twisted Playground <twistedumbrella@gmail.com>
Date:   Wed Dec 21 23:45:03 2011 -0500

    "Sexy Switch" Implementation
    
    "Sexy Switch" Implementation is an extension of the "qcom Legacy
    Implementation"

diff --git a/Android.mk b/Android.mk
index 32b42ab..59f2008 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,7 +1,7 @@
 QCOM_MEDIA_ROOT := $(call my-dir)
 
 ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
-	media-hals := libstagefrighthw
+	media-hals := libstagefrighthw librpc
 	include $(call all-named-subdir-makefiles,$(media-hals))
 
 ifneq ($(BOARD_USES_AUDIO_LEGACY),true)
diff --git a/audio/Android.mk b/audio/Android.mk
index 7e77aee..ffbc909 100644
--- a/audio/Android.mk
+++ b/audio/Android.mk
@@ -4,14 +4,18 @@ ifeq ($(TARGET_BOARD_PLATFORM),msm8660)
     include $(AUDIO_HW_ROOT)/msm8x60/Android.mk
 endif
 
-ifeq ($(TARGET_BOARD_PLATFORM),msm7x30)
-    include $(AUDIO_HW_ROOT)/msm7x30/Android.mk
-endif
-
 ifeq ($(TARGET_BOARD_PLATFORM),msm7x27a)
     include $(AUDIO_HW_ROOT)/msm7x27a/Android.mk
 endif
 
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x30)
+    include $(AUDIO_HW_ROOT)/msm7x30/Android.mk
+endif
+
 ifeq ($(TARGET_BOARD_PLATFORM),qsd8k)
     include $(AUDIO_HW_ROOT)/qsd8k/Android.mk
+endif
+
 endif
\ No newline at end of file
diff --git a/audio/msm7x30/Android.mk b/audio/msm7x30/Android.mk
index 574302c..083ed5b 100644
--- a/audio/msm7x30/Android.mk
+++ b/audio/msm7x30/Android.mk
@@ -5,6 +5,8 @@
 
 LOCAL_PATH := $(call my-dir)
 
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
 include $(CLEAR_VARS)
 
 ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
@@ -103,3 +105,5 @@ endif
 LOCAL_C_INCLUDES := hardware/libhardware_legacy/audio
 
 include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/audio/qsd8k/Android.mk b/audio/qsd8k/Android.mk
index 0c21103..0890171 100755
--- a/audio/qsd8k/Android.mk
+++ b/audio/qsd8k/Android.mk
@@ -3,6 +3,8 @@ ifneq ($(BUILD_TINY_ANDROID),true)
 
 LOCAL_PATH := $(call my-dir)
 
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
 include $(CLEAR_VARS)
 
 LOCAL_MODULE:= audio_policy.$(TARGET_BOARD_PLATFORM)
@@ -50,5 +52,7 @@ LOCAL_CFLAGS += -fno-short-enums
 
 include $(BUILD_SHARED_LIBRARY)
 
+endif
+
 endif # not BUILD_TINY_ANDROID
 
diff --git a/librpc/Android.mk b/librpc/Android.mk
new file mode 100755
index 0000000..96719c1
--- /dev/null
+++ b/librpc/Android.mk
@@ -0,0 +1,42 @@
+ifeq ($(BOARD_USES_QCOM_LIBRPC),true)
+
+LOCAL_PATH:= $(call my-dir)
+
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= xdr.c rpc.c svc.c clnt.c ops.c svc_clnt_common.c
+
+LOCAL_C_INCLUDES:=$(LOCAL_PATH)
+
+LOCAL_CFLAGS:= -fno-short-enums 
+
+LOCAL_CFLAGS+=-DRPC_OFFSET=0
+#LOCAL_CFLAGS+=-DDEBUG -DVERBOSE
+
+LOCAL_COPY_HEADERS_TO:= librpc/rpc
+LOCAL_COPY_HEADERS:= \
+	rpc/clnt.h \
+	rpc/pmap_clnt.h \
+	rpc/rpc.h \
+	rpc/rpc_router_ioctl.h \
+	rpc/svc.h \
+	rpc/types.h \
+	rpc/xdr.h
+
+LOCAL_MODULE:= librpc
+
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := librpc
+LOCAL_SHARED_LIBRARIES := liblog libcutils
+LOCAL_STATIC_LIBRARIES := libpower
+LOCAL_WHOLE_STATIC_LIBRARIES := librpc
+# LOCAL_PRELINK_MODULE := false
+include $(BUILD_SHARED_LIBRARY)
+
+endif
+
+endif
diff --git a/librpc/MODULE_LICENSE_APACHE2 b/librpc/MODULE_LICENSE_APACHE2
new file mode 100755
index 0000000..e69de29
diff --git a/librpc/NOTICE b/librpc/NOTICE
new file mode 100755
index 0000000..dbaa5f4
--- /dev/null
+++ b/librpc/NOTICE
@@ -0,0 +1,193 @@
+=======================================================================
+This notice files applies only to the files licensed under this license
+=======================================================================
+
+   Copyright (c) 2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/librpc/clnt.c b/librpc/clnt.c
new file mode 100755
index 0000000..8a3738e
--- /dev/null
+++ b/librpc/clnt.c
@@ -0,0 +1,756 @@
+/* Copyright (c) 2009-2010, Code Aurora Forum. */
+
+#include <rpc/rpc.h>
+#include <arpa/inet.h>
+#include <rpc/rpc_router_ioctl.h>
+#include <debug.h>
+#include <pthread.h>
+#include <sys/select.h>
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#include <hardware_legacy/power.h>
+#include <poll.h>
+
+#define ANDROID_WAKE_LOCK_NAME "rpc-interface"
+
+void
+grabPartialWakeLock() {
+    acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
+}
+
+void
+releaseWakeLock() {
+    release_wake_lock(ANDROID_WAKE_LOCK_NAME);
+}
+
+struct CLIENT {
+    xdr_s_type *xdr;
+    struct CLIENT *next;
+    /* common attribute struct for setting up recursive mutexes */
+    pthread_mutexattr_t lock_attr;
+
+    /* We insist that there is only one outstanding call for a client at any
+       time, and we use this mutex to enforce the rule.  When we start
+       supporting multiple outstanding RPCs on a client, we will have to
+       maintain a queue of them, and match incoming replies (by the XID of the
+       incoming packet).  For now, we just block until we get that reply.
+    */
+    pthread_mutex_t lock;
+
+    pthread_mutex_t wait_reply_lock;
+    pthread_cond_t wait_reply;
+
+    pthread_mutex_t input_xdr_lock;
+    pthread_cond_t input_xdr_wait;
+    volatile int input_xdr_busy;
+
+    pthread_mutex_t wait_cb_lock;
+    pthread_cond_t wait_cb;
+    pthread_t cb_thread;
+    volatile int got_cb;
+    volatile int cb_stop;
+};
+
+extern void* svc_find(void *xprt, rpcprog_t prog, rpcvers_t vers);
+extern void svc_dispatch(void *svc, void *xprt);
+extern int  r_open(const char *name);
+extern void r_close(int handle);
+extern xdr_s_type *xdr_init_common(const char *name, int is_client);
+extern xdr_s_type *xdr_clone(xdr_s_type *);
+extern void xdr_destroy_common(xdr_s_type *xdr);
+extern bool_t xdr_recv_reply_header (xdr_s_type *xdr, rpc_reply_header *reply);
+extern void *the_xprt;
+
+
+static pthread_mutex_t rx_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_t rx_thread;
+static volatile unsigned int num_clients;
+static volatile fd_set rx_fdset;
+static volatile int max_rxfd;
+static volatile struct CLIENT *clients;
+static int router_fd;
+
+/* There's one of these for each RPC client which has received an RPC call. */
+static void *cb_context(void *__u)
+{
+    CLIENT *client = (CLIENT *)__u;
+    D("RPC-callback thread for %08x:%08x starting.\n",
+      (client->xdr->x_prog | 0x01000000),
+      client->xdr->x_vers);
+    pthread_mutex_lock(&client->wait_cb_lock);
+    while (client->cb_stop == 0) {
+        if (!client->got_cb)
+            pthread_cond_wait(&client->wait_cb,
+                              &client->wait_cb_lock);
+        /* We tell the thread it's time to exit by setting cb_stop to nonzero
+           and signalling the conditional variable.  When there's no data, we
+           skip to the top of the loop and exit. 
+        */
+        if (!client->got_cb) {
+            D("RPC-callback thread for %08x:%08x: signalled but no data.\n",
+              (client->xdr->x_prog | 0x01000000),
+              client->xdr->x_vers);
+            continue;
+        }
+        client->got_cb = 0;
+
+        /* We dispatch the message to the server representing the callback
+         * client.
+         */
+        if (the_xprt) {
+            void *svc;
+            rpcprog_t prog =
+                ntohl(((uint32 *)(client->xdr->in_msg))[RPC_OFFSET+3]);
+            rpcvers_t vers =
+                ntohl(((uint32 *)(client->xdr->in_msg))[RPC_OFFSET+4]);
+            
+            svc = svc_find(the_xprt, prog, vers);
+            if (svc) {
+                XDR **svc_xdr = (XDR **)svc;
+                D("%08x:%08x dispatching RPC call (XID %d, xdr %p) for "
+                  "callback client %08x:%08x.\n",
+                  client->xdr->x_prog,
+                  client->xdr->x_vers,
+                  ntohl(((uint32 *)(client->xdr->in_msg))[RPC_OFFSET]),
+                  client->xdr,
+                  (uint32_t)prog, (int)vers);
+                /* We transplant the xdr of the client into the entry 
+                   representing the callback client in the list of servers.
+                   Note that since we hold the wait_cb_lock for this client,
+                   if another call for this callback client arrives before
+                   we've finished processing this call, that will block until
+                   we're done with this one.  If this happens, it would be
+                   most likely a bug in the arm9 rpc router.
+                */
+                if (*svc_xdr) {
+                    D("%08x:%08x expecting XDR == NULL"
+                      "callback client %08x:%08x!\n",
+                      client->xdr->x_prog,
+                      client->xdr->x_vers,
+                      (uint32_t)prog, (int)vers);
+                    xdr_destroy_common(*svc_xdr);
+                }
+                
+
+                /* Do these checks before the clone */
+                if (client->xdr->in_len < 0) {
+                    E("%08x:%08x xdr->in_len = %i error %s (%d)",
+                        client->xdr->in_len,
+                        client->xdr->x_prog, client->xdr->x_vers,
+                        strerror(errno), errno);
+                    continue;
+                }
+                if (client->xdr->out_next < 0) {
+                    E("%08x:%08x xdr->out_next = %i error %s (%d)",
+                        client->xdr->out_next,
+                        client->xdr->x_prog, client->xdr->x_vers,
+                    strerror(errno), errno);
+                    continue;
+                }
+
+                D("%08x:%08x cloning XDR for "
+                  "callback client %08x:%08x.\n",
+                  client->xdr->x_prog,
+                  client->xdr->x_vers,
+                  (uint32_t)prog, (int)vers);
+                *svc_xdr = xdr_clone(client->xdr);
+                
+                (*svc_xdr)->x_prog = prog;
+                (*svc_xdr)->x_vers = vers;
+                memcpy((*svc_xdr)->in_msg,
+                       client->xdr->in_msg, client->xdr->in_len);
+                memcpy((*svc_xdr)->out_msg,
+                       client->xdr->out_msg, client->xdr->out_next);
+                (*svc_xdr)->in_len = client->xdr->in_len;
+                (*svc_xdr)->out_next = client->xdr->out_next;
+
+                pthread_mutex_lock(&client->input_xdr_lock);
+                D("%08x:%08x marking input buffer as free.\n",
+                  client->xdr->x_prog, client->xdr->x_vers);
+                client->input_xdr_busy = 0;
+                pthread_cond_signal(&client->input_xdr_wait);
+                pthread_mutex_unlock(&client->input_xdr_lock);
+
+                svc_dispatch(svc, the_xprt);
+                xdr_destroy_common(*svc_xdr);
+                *svc_xdr = NULL;
+            }
+            else E("%08x:%08x call packet arrived, but there's no "
+                   "RPC server registered for %08x:%08x.\n",
+                   client->xdr->x_prog,
+                   client->xdr->x_vers,                   
+                   (uint32_t)prog, (int)vers);                           
+        }
+        else E("%08x:%08x call packet arrived, but there's "
+               "no RPC transport!\n",
+               client->xdr->x_prog,
+               client->xdr->x_vers);
+
+        releaseWakeLock();
+    }
+    pthread_mutex_unlock(&client->wait_cb_lock);
+
+
+    D("RPC-callback thread for %08x:%08x terminating.\n",
+      (client->xdr->x_prog | 0x01000000),
+      client->xdr->x_vers);
+    return NULL;
+}
+
+static void *rx_context(void *__u __attribute__((unused)))
+{
+    int n;
+    fd_set rfds;
+    int ret;
+    struct pollfd fd;
+    int timeout = 0;
+
+    memset((void *) &fd, 0, sizeof(fd));
+    while(num_clients) {
+        pthread_mutex_lock(&rx_mutex);
+        rfds = rx_fdset;
+        pthread_mutex_unlock(&rx_mutex);
+
+        ret = poll(&fd, 1, timeout);
+        if (ret > 0) {
+            if (fd.revents & POLLERR) {
+                D("Modem is resetting.\n");
+                timeout = 500;
+                continue;
+            }
+        }
+        timeout = 0;
+
+        n = select(max_rxfd + 1, (fd_set *)&rfds, NULL, NULL, NULL);
+        if (n < 0) {
+            E("select() error %s (%d)\n", strerror(errno), errno);
+            continue;
+        }
+
+	if (!num_clients)
+            break;
+
+        if (n) {
+            pthread_mutex_lock(&rx_mutex); /* sync access to the client list */
+            CLIENT *client = (CLIENT *)clients;
+            for (; client; client = client->next) {
+                if (FD_ISSET(client->xdr->fd, &rfds)) {
+
+                    /* We need to make sure that the XDR's in_buf is not in
+                       use before we read into it.  The in_buf may be in use
+                       in a race between processing an incoming call and
+                       receiving a reply to an outstanding call, or processing
+                       an incoming reply and receiving a call.
+                    */
+
+                    pthread_mutex_lock(&client->input_xdr_lock);
+                    while (client->input_xdr_busy) {
+                        D("%08x:%08x waiting for XDR input buffer "
+                          "to be consumed.\n",
+                          client->xdr->x_prog, client->xdr->x_vers);
+                        pthread_cond_wait(
+                            &client->input_xdr_wait,
+                            &client->input_xdr_lock);                        
+                    }
+                    D("%08x:%08x reading data.\n",
+                       client->xdr->x_prog, client->xdr->x_vers);
+                    grabPartialWakeLock();
+                    ret = client->xdr->xops->read(client->xdr);
+                    if (ret == FALSE) {
+                        E("%08x:%08x xops->read() error %s (%d)\n",
+                          client->xdr->x_prog, client->xdr->x_vers,
+                        strerror(errno), errno);
+
+                        if (errno == ENETRESET) {
+                            E("%08x:%08x clearing reset.\n",
+                                client->xdr->x_prog, client->xdr->x_vers);
+                                client->xdr->xops->xdr_control(
+                                client->xdr,
+                                RPC_ROUTER_IOCTL_CLEAR_NETRESET, NULL);
+                           fd.fd = client->xdr->fd;
+                        }
+
+                        pthread_mutex_unlock(&client->input_xdr_lock);
+                        releaseWakeLock();
+                        continue;
+                    }
+                    client->input_xdr_busy = 1;
+                    pthread_mutex_unlock(&client->input_xdr_lock);
+
+                    if (((uint32 *)(client->xdr->in_msg))[RPC_OFFSET+1] == 
+                        htonl(RPC_MSG_REPLY)) {
+                        /* Wake up the RPC client to receive its data. */
+                        D("%08x:%08x received REPLY (XID %d), "
+                          "grabbing mutex to wake up client.\n",
+                          client->xdr->x_prog,
+                          client->xdr->x_vers,
+                          ntohl(((uint32 *)client->xdr->in_msg)[RPC_OFFSET]));
+                        pthread_mutex_lock(&client->wait_reply_lock);
+                        D("%08x:%08x got mutex, waking up client.\n",
+                          client->xdr->x_prog,
+                          client->xdr->x_vers);
+                        pthread_cond_signal(&client->wait_reply);
+                        pthread_mutex_unlock(&client->wait_reply_lock);
+
+                        releaseWakeLock();
+                    }
+                    else {
+                        pthread_mutex_lock(&client->wait_cb_lock);
+                        D("%08x:%08x received CALL.\n",
+                          client->xdr->x_prog,
+                          client->xdr->x_vers);
+                        client->got_cb = 1;
+                        if (client->cb_stop < 0) {
+                            D("%08x:%08x starting callback thread.\n",
+                              client->xdr->x_prog,
+                              client->xdr->x_vers);                            
+                            client->cb_stop = 0;
+                            pthread_create(&client->cb_thread,
+                                           NULL,
+                                           cb_context, client);
+                        }
+                        D("%08x:%08x waking up callback thread.\n",
+                          client->xdr->x_prog,
+                          client->xdr->x_vers);                            
+                        pthread_cond_signal(&client->wait_cb);
+                        pthread_mutex_unlock(&client->wait_cb_lock);
+                    }
+                }
+            }
+            pthread_mutex_unlock(&rx_mutex);
+        }
+        else {
+            V("rx thread timeout (%d clients):\n", num_clients);
+#if 0
+            {
+                CLIENT *trav = (CLIENT *)clients;
+                for(; trav; trav = trav->next) {
+                    if (trav->xdr)
+                        V("\t%08x:%08x fd %02d\n",
+                          trav->xdr->x_prog,
+                          trav->xdr->x_vers,
+                          trav->xdr->fd);
+                    else V("\t(unknown)\n");
+                }
+            }
+#endif
+        }
+    }
+    D("RPC-client RX thread exiting!\n");
+    return NULL;
+}
+
+enum clnt_stat
+clnt_call(
+    CLIENT       * client,
+    u_long         proc,
+    xdrproc_t      xdr_args,
+    caddr_t        args_ptr,
+    xdrproc_t      xdr_results,
+    caddr_t        rets_ptr,
+    struct timeval timeout)
+{
+    opaque_auth cred;
+    opaque_auth verf;
+    rpc_reply_header reply_header;
+    enum clnt_stat ret = RPC_SUCCESS;
+
+    xdr_s_type *xdr = client->xdr;
+
+    pthread_mutex_lock(&client->lock);
+
+
+    cred.oa_flavor = AUTH_NONE;
+    cred.oa_length = 0;
+    verf.oa_flavor = AUTH_NONE;
+    verf.oa_length = 0;
+
+    xdr->x_op = XDR_ENCODE;
+
+    /* Send message header */
+
+    if (!xdr_call_msg_start (xdr, xdr->x_prog, xdr->x_vers,
+                             proc, &cred, &verf)) {
+        XDR_MSG_ABORT (xdr);
+        ret = RPC_CANTENCODEARGS; 
+        E("%08x:%08x error in xdr_call_msg_start()\n",
+          client->xdr->x_prog,
+          client->xdr->x_vers);
+        goto out;
+    }
+
+    /* Send arguments */
+
+    if (!xdr_args (xdr, args_ptr)) {
+        XDR_MSG_ABORT(xdr);
+        ret = RPC_CANTENCODEARGS; 
+        E("%08x:%08x error in xdr_args()\n",
+          client->xdr->x_prog,
+          client->xdr->x_vers);
+        goto out;
+    }
+
+    /* Finish message - blocking */
+    pthread_mutex_lock(&client->wait_reply_lock);
+    D("%08x:%08x sending call (XID %d).\n",
+      client->xdr->x_prog, client->xdr->x_vers, client->xdr->xid);
+    if (!XDR_MSG_SEND(xdr)) {
+        ret = RPC_CANTSEND;
+        E("error in XDR_MSG_SEND\n");
+        goto out_unlock;
+    }
+
+    D("%08x:%08x waiting for reply.\n",
+      client->xdr->x_prog, client->xdr->x_vers);
+    pthread_cond_wait(&client->wait_reply, &client->wait_reply_lock);
+    D("%08x:%08x received reply.\n", client->xdr->x_prog, client->xdr->x_vers);
+
+    if (((uint32 *)xdr->out_msg)[RPC_OFFSET] != 
+        ((uint32 *)xdr->in_msg)[RPC_OFFSET]) {
+        E("%08x:%08x XID mismatch: got %d, expecting %d.\n",
+          client->xdr->x_prog, client->xdr->x_vers,
+          ntohl(((uint32 *)xdr->in_msg)[RPC_OFFSET]),
+          ntohl(((uint32 *)xdr->out_msg)[RPC_OFFSET]));
+        ret = RPC_CANTRECV;
+        goto out_unlock;
+    }
+
+    D("%08x:%08x decoding reply header.\n",
+      client->xdr->x_prog, client->xdr->x_vers);
+    if (!xdr_recv_reply_header (client->xdr, &reply_header)) {
+        E("%08x:%08x error reading reply header.\n",
+          client->xdr->x_prog, client->xdr->x_vers);
+        ret = RPC_CANTRECV;
+        goto out_unlock;
+    }
+
+    /* Check that other side accepted and responded */
+    if (reply_header.stat != RPC_MSG_ACCEPTED) {
+        /* Offset to map returned error into clnt_stat */
+        ret = reply_header.u.dr.stat + RPC_VERSMISMATCH;
+        E("%08x:%08x call was not accepted.\n",
+          (uint32_t)client->xdr->x_prog, client->xdr->x_vers);
+        goto out_unlock;
+    } else if (reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS) {
+        /* Offset to map returned error into clnt_stat */
+        ret = reply_header.u.ar.stat + RPC_AUTHERROR;
+        E("%08x:%08x call failed with an authentication error.\n",
+          (uint32_t)client->xdr->x_prog, client->xdr->x_vers);
+        goto out_unlock;
+    }
+
+    xdr->x_op = XDR_DECODE;
+    /* Decode results */
+    if (!xdr_results(xdr, rets_ptr) || ! XDR_MSG_DONE(xdr)) {
+        ret = RPC_CANTDECODERES;
+        E("%08x:%08x error decoding results.\n",
+          client->xdr->x_prog, client->xdr->x_vers);
+        goto out_unlock;
+    }
+
+    D("%08x:%08x call success.\n",
+      client->xdr->x_prog, client->xdr->x_vers);
+
+  out_unlock:
+    pthread_mutex_lock(&client->input_xdr_lock);
+    D("%08x:%08x marking input buffer as free.\n",
+      client->xdr->x_prog, client->xdr->x_vers);
+    client->input_xdr_busy = 0;
+    pthread_cond_signal(&client->input_xdr_wait);
+    pthread_mutex_unlock(&client->input_xdr_lock);
+
+    pthread_mutex_unlock(&client->wait_reply_lock);
+  out:
+    pthread_mutex_unlock(&client->lock);
+    return ret;
+} /* clnt_call */
+
+bool_t xdr_recv_auth (xdr_s_type *xdr, opaque_auth *auth)
+{
+    switch(sizeof(auth->oa_flavor)) {
+    case 1:
+        if(!XDR_RECV_INT8(xdr, (int8_t *)&(auth->oa_flavor))) return FALSE;
+        break;
+    case 2:
+        if(!XDR_RECV_INT16(xdr, (int16_t *)&(auth->oa_flavor))) return FALSE;
+        break;
+    case 4:
+        if(!XDR_RECV_INT32(xdr, (int32_t *)&(auth->oa_flavor))) return FALSE;
+        break;
+    }
+    if (!XDR_RECV_UINT (xdr, (unsigned *)&(auth->oa_length))) {
+        return FALSE;
+    }
+    
+    if (auth->oa_length != 0) {
+        /* We throw away the auth stuff--it's always the default. */
+        auth->oa_base = NULL;
+        if (!XDR_RECV_BYTES (xdr, NULL, auth->oa_length))
+            return FALSE;
+        else
+            return FALSE;
+    }
+    
+    return TRUE;
+} /* xdr_recv_auth */
+
+static bool_t
+xdr_recv_accepted_reply_header(xdr_s_type *xdr,
+                               struct rpc_accepted_reply_header *accreply)
+{
+    if (!xdr_recv_auth(xdr, &accreply->verf)) {
+        return FALSE;
+    }
+
+    if (!XDR_RECV_ENUM(xdr, &accreply->stat)) {
+        return FALSE;
+    }
+
+    switch ((*accreply).stat) {
+    case RPC_PROG_MISMATCH:
+        if (!XDR_RECV_UINT32(xdr, &accreply->u.versions.low)) {
+            return FALSE;
+        }
+
+        if (!XDR_RECV_UINT32(xdr, &accreply->u.versions.high)) {
+            return FALSE;
+        }
+        break;
+
+    case RPC_ACCEPT_SUCCESS:
+    case RPC_PROG_UNAVAIL:
+    case RPC_PROC_UNAVAIL:
+    case RPC_GARBAGE_ARGS:
+    case RPC_SYSTEM_ERR:
+    case RPC_PROG_LOCKED:
+        // case ignored
+        break;
+
+    default:
+        return FALSE;
+    }
+
+    return TRUE;
+} /* xdr_recv_accepted_reply_header */
+
+static bool_t xdr_recv_denied_reply(xdr_s_type *xdr,
+                                    struct rpc_denied_reply *rejreply)
+{
+    if (!XDR_RECV_ENUM (xdr, &rejreply->stat))
+        return FALSE;
+
+    switch ((*rejreply).stat) {
+    case RPC_MISMATCH:
+        if (!XDR_RECV_UINT32(xdr, &rejreply->u.versions.low))
+            return FALSE;
+        if (!XDR_RECV_UINT32(xdr, &rejreply->u.versions.high))
+            return FALSE;
+        break;
+    case RPC_AUTH_ERROR:
+        if (!XDR_RECV_ENUM (xdr, &rejreply->u.why))
+            return FALSE;
+        break;
+    default:
+        return FALSE;
+    }
+
+    return TRUE;
+} /* xdr_recv_denied_reply */
+
+bool_t xdr_recv_reply_header (xdr_s_type *xdr, rpc_reply_header *reply)
+{
+    if (!XDR_RECV_ENUM(xdr, &reply->stat)) {
+        return FALSE;
+    }
+
+    switch ((*reply).stat) {
+    case RPC_MSG_ACCEPTED:
+        if (!xdr_recv_accepted_reply_header(xdr, &reply->u.ar)) {
+            return FALSE;
+    }
+        break;
+    case RPC_MSG_DENIED:
+        if (!xdr_recv_denied_reply(xdr, &reply->u.dr)) {
+            return FALSE;
+    }
+        break;
+    default:
+        return FALSE;
+    }
+
+    return TRUE;
+} /* xdr_recv_reply_header */
+
+/* pipe to wake up receive thread */
+static int wakeup_pipe[2];
+
+CLIENT *clnt_create(
+    char * host,
+    uint32 prog,
+    uint32 vers,
+    char * proto)
+{
+    CLIENT *client = calloc(1, sizeof(CLIENT));
+    if (client) {
+        char name[20];
+
+        /* for versions like 0x00010001, only compare against major version */
+        if (vers!=0x20002 && (vers & 0xFFF00000) == 0)
+            vers &= 0xFFFF0000;
+
+        pthread_mutex_lock(&rx_mutex);
+
+	if (!num_clients) {
+	    /* Open the router device to load the modem */
+	    router_fd = r_open("00000000:0");
+	    if (router_fd < 0) {
+		free(client);
+		pthread_mutex_unlock(&rx_mutex);
+		return NULL;
+	    }
+	}
+        /* Implment backwards compatibility */
+        vers = (vers & 0x80000000 || vers == 0x20002) ? vers : vers & 0xFFFF0000;
+
+        snprintf(name, sizeof(name), "%08x:%08x", (uint32_t)prog, (int)vers);
+        client->xdr = xdr_init_common(name, 1 /* client XDR */);
+        if (!client->xdr) {
+            E("failed to initialize client (permissions?)!\n");
+	    if (!num_clients)
+		r_close(router_fd);
+            free(client);
+            pthread_mutex_unlock(&rx_mutex);
+            return NULL;
+        }
+        client->xdr->x_prog = prog;
+        client->xdr->x_vers = vers;
+        client->cb_stop = -1; /* callback thread has not been started */
+
+        if (!num_clients) {
+            FD_ZERO(&rx_fdset);
+            if (pipe(wakeup_pipe) == -1) {
+               E("failed to create pipe\n");
+	       r_close(router_fd);
+               free(client);
+               pthread_mutex_unlock(&rx_mutex);
+               return NULL;
+            }
+            FD_SET(wakeup_pipe[0], &rx_fdset);
+            max_rxfd = wakeup_pipe[0];
+        }
+
+        FD_SET(client->xdr->fd, &rx_fdset);
+        if (max_rxfd < client->xdr->fd)
+            max_rxfd = client->xdr->fd;
+        client->next = (CLIENT *)clients;
+        clients = client;
+        if (!num_clients++) {
+            D("launching RX thread.\n");
+            pthread_create(&rx_thread, NULL, rx_context, NULL);
+        } else {
+            /* client added, wake up rx_thread */
+            if (write(wakeup_pipe[1], "a", 1) < 0)
+	        E("error writing to pipe\n");
+	}
+
+        pthread_mutexattr_init(&client->lock_attr);
+//      pthread_mutexattr_settype(&client->lock_attr, PTHREAD_MUTEX_RECURSIVE);
+        pthread_mutex_init(&client->lock, &client->lock_attr);
+        pthread_mutex_init(&client->wait_reply_lock, &client->lock_attr);
+        pthread_cond_init(&client->wait_reply, NULL);
+        pthread_mutex_init(&client->wait_cb_lock, &client->lock_attr);
+        pthread_cond_init(&client->wait_cb, NULL);
+        pthread_mutex_init(&client->input_xdr_lock, &client->lock_attr);
+        pthread_cond_init(&client->input_xdr_wait, NULL);
+
+        pthread_mutex_unlock(&rx_mutex);
+    }
+
+    return client;
+}
+
+void clnt_destroy(CLIENT *client) {
+    if (client) {
+        pthread_mutex_lock(&client->lock);
+        D("%08x:%08x destroying client\n",
+          client->xdr->x_prog,
+          client->xdr->x_vers);
+
+
+        if (!client->cb_stop) {
+            /* The callback thread is running, we need to stop it */
+            client->cb_stop = 1;
+            D("%08x:%08x stopping callback thread\n",
+              client->xdr->x_prog,
+              client->xdr->x_vers);
+            pthread_mutex_lock(&client->wait_cb_lock);
+            pthread_cond_signal(&client->wait_cb);
+            pthread_mutex_unlock(&client->wait_cb_lock);
+            D("%08x:%08x joining callback thread\n",
+              client->xdr->x_prog,
+              client->xdr->x_vers);
+            pthread_join(client->cb_thread, NULL);
+        }
+
+        pthread_mutex_lock(&rx_mutex); /* sync access to the client list */
+        {
+            CLIENT *trav = (CLIENT *)clients, *prev = NULL;
+            for(; trav; trav = trav->next) {
+                if (trav == client) {
+                     D("%08x:%08x removing from client list\n",
+                      client->xdr->x_prog,
+                      client->xdr->x_vers);
+                    if (prev)
+                        prev->next = trav->next;
+                    else
+                        clients = trav->next;
+                    num_clients--;
+                    FD_CLR(client->xdr->fd, &rx_fdset);
+                    break;
+                }
+                prev = trav;
+            }
+        }
+        if (!num_clients) {
+            /* no clients, wake up rx_thread */
+            if (write(wakeup_pipe[1], "d", 1) < 0)
+	        E("error writing to pipe\n");
+
+            D("stopping rx thread!\n");
+            pthread_join(rx_thread, NULL);
+            D("stopped rx thread\n");
+
+            FD_CLR(wakeup_pipe[0], &rx_fdset);
+            close(wakeup_pipe[0]);
+            close(wakeup_pipe[1]);
+	    r_close(router_fd);
+        }
+        pthread_mutex_unlock(&rx_mutex); /* sync access to the client list */
+ 
+        pthread_mutex_destroy(&client->input_xdr_lock);
+        pthread_cond_destroy(&client->input_xdr_wait);
+
+        pthread_mutex_destroy(&client->wait_reply_lock);
+        pthread_cond_destroy(&client->wait_reply);
+        xdr_destroy_common(client->xdr);
+
+        // FIXME: what happens when we lock the client while destroying it,
+        // and another thread locks the mutex in clnt_call, and then we 
+        // call pthread_mutex_destroy?  Does destroy automatically unlock and
+        // then cause the lock in clnt_call() to return an error?  When we
+        // unlock the mutex here there can be a context switch to the other
+        // thread, which will cause it to obtain the mutex on the destroyed
+        // client (and probably crash), and then we get to the destroy call
+        // here... will that call fail?
+        pthread_mutex_unlock(&client->lock);        
+        pthread_mutex_destroy(&client->lock);
+        pthread_mutexattr_destroy(&client->lock_attr);
+        D("client destroy done\n");
+        free(client);
+    }
+}
diff --git a/librpc/debug.h b/librpc/debug.h
new file mode 100755
index 0000000..47a1ec4
--- /dev/null
+++ b/librpc/debug.h
@@ -0,0 +1,66 @@
+/*
+** Copyright 2008, The Android Open-Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
+**
+**     http://www.apache.org/licenses/LICENSE-2.0 
+**
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
+** limitations under the License.
+*/
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+
+#define LOG_TAG "RPC"
+#include <utils/Log.h>
+
+#ifdef RPC_LOG_TO_STDOUT_ONLY
+#define PRINT(x...) do {                                    \
+        fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stdout, ##x);                               \
+    } while(0)
+#elif defined(RPC_LOG_TO_STDOUT_AND_LOG)
+#define PRINT(x...) do {                                    \
+        fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stdout, ##x);                               \
+        LOGI(x);                               \
+    } while(0)
+#else
+#define PRINT(x...) LOGI(x)
+#endif
+
+#ifdef DEBUG
+#define D PRINT
+#else
+#define D(x...) do { } while(0)
+#endif
+
+#ifdef VERBOSE
+#define V PRINT
+#else
+#define V(x...) do { } while(0)
+#endif
+
+#define E(x...) do {                                        \
+        fprintf(stderr, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stderr, ##x);                               \
+        LOGE(x);                                            \
+    } while(0)
+
+#define FAILIF(cond, msg...) do {                                              \
+        if (__builtin_expect (cond, 0)) {                                      \
+            fprintf(stderr, "%s:%s:(%d): ", __FILE__, __FUNCTION__, __LINE__); \
+            fprintf(stderr, ##msg);                                            \
+        	LOGE(msg);                                            \
+        }                                                                      \
+    } while(0)
+
+#endif/*DEBUG_H*/
diff --git a/librpc/librpc.h b/librpc/librpc.h
new file mode 100755
index 0000000..b70bdba
--- /dev/null
+++ b/librpc/librpc.h
@@ -0,0 +1,28 @@
+/* Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "rpc/rpc.h" 
diff --git a/librpc/ops.c b/librpc/ops.c
new file mode 100755
index 0000000..25c06cb
--- /dev/null
+++ b/librpc/ops.c
@@ -0,0 +1,96 @@
+/* Copyright (c) 2010, Code Aurora Forum. */
+
+#include <rpc/rpc.h>
+#include <rpc/rpc_router_ioctl.h>
+#include <debug.h>
+
+#include <sys/types.h>   
+#include <sys/stat.h>     
+#include <fcntl.h>        
+#include <unistd.h>      
+#include <stdio.h>
+#include <errno.h>
+
+#define DUMP_DATA 0
+/* Wait for server in seconds, 0 - no wait, -ve - infinite wait */
+#define SERVER_WAIT_DURATION 15
+#define POLL_INTERVAL_MS 500
+
+int r_open(const char *router)
+{
+  char name[32];
+  struct stat statbuf;
+  int handle;
+  struct timespec polling_timer;
+  int poll_count;
+
+  if (stat("/dev/oncrpc", &statbuf) == 0)
+      snprintf(name, sizeof(name), "/dev/oncrpc/%s", router);
+  else
+      snprintf(name, sizeof(name), "/dev/%s", router);
+
+  polling_timer.tv_sec = 0;
+  polling_timer.tv_nsec = (POLL_INTERVAL_MS * 1000000);
+  poll_count = SERVER_WAIT_DURATION * (1000 / POLL_INTERVAL_MS);
+
+  while (stat(name, &statbuf) && poll_count) {
+      nanosleep(&polling_timer, NULL);
+      if (poll_count > 0)
+          poll_count--;
+  }
+
+  handle = open(name, O_RDWR, 0);
+
+  if(handle < 0)
+      E("error opening %s: %s\n", name, strerror(errno));
+  return handle;
+}
+
+void r_close(int handle)
+{
+    if(close(handle) < 0) E("error: %s\n", strerror(errno));
+}
+
+int r_read(int handle, char *buf, uint32 size)
+{
+	int rc = read((int) handle, (void *)buf, size);
+	if (rc < 0)
+		E("error reading RPC packet: %d (%s)\n", errno, strerror(errno));
+#if DUMP_DATA
+	else {
+		int len = rc / 4;
+		uint32_t *data = (uint32_t *)buf;
+		fprintf(stdout, "RPC in  %02d:", rc);
+		while (len--)
+			fprintf(stdout, " %08x", *data++);
+		fprintf(stdout, "\n");
+	}
+#endif
+	return rc;
+}
+
+int r_write (int handle, const char *buf, uint32 size)
+{
+	int rc = write(handle, (void *)buf, size);
+	if (rc < 0)
+		E("error writing RPC packet: %d (%s)\n", errno, strerror(errno));
+#if DUMP_DATA
+	else {
+		int len = rc / 4;
+		uint32_t *data = (uint32_t *)buf;
+		fprintf(stdout, "RPC out %02d:", rc);
+		while (len--)
+			fprintf(stdout, " %08x", *data++);
+		fprintf(stdout, "\n");
+	}
+#endif
+	return rc;
+}
+
+int r_control(int handle, const uint32 cmd, void *arg)
+{
+  return ioctl(handle, cmd, arg);
+}
+
+
+
diff --git a/librpc/rpc.c b/librpc/rpc.c
new file mode 100755
index 0000000..3e8c885
--- /dev/null
+++ b/librpc/rpc.c
@@ -0,0 +1,156 @@
+#include <rpc/rpc.h>
+
+/*
+ * Functions to compose RPC messages from XDR primitives
+ */
+
+bool_t xdr_call_msg_start(
+    xdr_s_type *xdr,
+    uint32 prog,
+    uint32 ver,
+    uint32 proc,
+    opaque_auth *cred,
+    opaque_auth *verf)
+{
+  uint32 vers = RPC_MSG_VERSION;
+
+  xdr->x_prog = prog;
+  xdr->x_proc = proc;
+
+  return (XDR_MSG_START(xdr, RPC_MSG_CALL) &&
+          XDR_SEND_UINT32(xdr, &vers) &&
+          XDR_SEND_UINT32(xdr, &prog) &&
+          XDR_SEND_UINT32(xdr, &ver) &&
+          XDR_SEND_UINT32(xdr, &proc) &&
+          xdr_send_auth(xdr, cred) &&
+          xdr_send_auth(xdr, verf));
+} // xdr_call_msg_start
+
+bool_t xdr_reply_msg_start(
+    xdr_s_type *xdr,
+    opaque_auth *verf)
+{
+  int32 stat   = (int32) RPC_MSG_ACCEPTED;
+  int32 accept = (int32) RPC_ACCEPT_SUCCESS;
+
+  return(XDR_MSG_START(xdr, RPC_MSG_REPLY) &&
+          XDR_SEND_INT32(xdr, &stat) &&
+          xdr_send_auth(xdr, verf) &&
+          XDR_SEND_INT32(xdr, &accept));
+} // xdr_reply_msg_start
+
+static bool_t xdr_send_accepted_reply_header(
+    xdr_s_type *xdr,
+    struct rpc_accepted_reply_header const *accreply)
+{
+  if (!xdr_send_auth(xdr, &accreply->verf))
+      return FALSE;
+
+  if (!XDR_SEND_ENUM(xdr, &accreply->stat))
+      return FALSE;
+
+  switch ((*accreply).stat){
+  case RPC_PROG_MISMATCH:
+    if (!XDR_SEND_UINT32(xdr, &accreply->u.versions.low))
+        return FALSE;
+
+    if (!XDR_SEND_UINT32(xdr, &accreply->u.versions.high))
+        return FALSE;
+    break;
+
+  case RPC_ACCEPT_SUCCESS:
+  case RPC_PROG_UNAVAIL:
+  case RPC_PROC_UNAVAIL:
+  case RPC_GARBAGE_ARGS:
+  case RPC_SYSTEM_ERR:
+  case RPC_PROG_LOCKED:
+      // case ignored
+      break;
+
+  default:
+      return FALSE;
+  }
+
+  return TRUE;
+} /* xdr_send_accepted_reply_header */
+
+static bool_t xdr_send_denied_reply(
+    xdr_s_type *xdr,
+    struct rpc_denied_reply const *rejreply)
+{
+    if (!XDR_SEND_ENUM(xdr, &rejreply->stat))
+        return FALSE;
+
+    switch ((*rejreply).stat){
+    case RPC_MISMATCH:
+        if (!XDR_SEND_UINT32(xdr, &rejreply->u.versions.low))
+            return FALSE;
+        if (!XDR_SEND_UINT32(xdr, &rejreply->u.versions.high))
+            return FALSE;
+        break;
+    case RPC_AUTH_ERROR:
+        if (!XDR_SEND_ENUM(xdr, &rejreply->u.why))
+            return FALSE;
+        break;
+    default:
+        return FALSE;
+    }
+
+    return TRUE;
+} /* xdr_send_denied_reply */
+
+bool_t xdr_send_reply_header(
+    xdr_s_type *xdr,
+    rpc_reply_header const *reply)
+{
+    if (!XDR_SEND_ENUM(xdr, &reply->stat))
+        return FALSE;
+
+    switch ((*reply).stat) {
+    case RPC_MSG_ACCEPTED:
+        if (!xdr_send_accepted_reply_header(xdr, &reply->u.ar))
+            return FALSE;
+        break;
+    case RPC_MSG_DENIED:
+        if (!xdr_send_denied_reply(xdr, &reply->u.dr))
+            return FALSE;
+        break;
+    default:
+        return FALSE;
+    }
+
+    return TRUE;
+} /* xdr_send_reply_header */
+
+#include <stdio.h>
+
+bool_t
+xdr_send_auth(xdr_s_type *xdr, const opaque_auth *auth)
+{
+#define FAILIF(x) do { if (x) return FALSE; } while(0)
+
+    switch (sizeof(auth->oa_flavor)) {
+    case 1:
+        FAILIF(!XDR_SEND_INT8(xdr, (int8_t *)&auth->oa_flavor));
+        break;
+    case 2:
+        FAILIF(!XDR_SEND_INT16(xdr, (int16_t *)&auth->oa_flavor));
+        break;
+    case 4:
+        FAILIF(!XDR_SEND_INT32(xdr, (int32_t *)&auth->oa_flavor));
+        break;
+    default:
+        return FALSE;
+    }
+
+    return (XDR_SEND_UINT(xdr, (uint32_t *)&auth->oa_length) &&
+            (auth->oa_length == 0 ||
+             XDR_SEND_BYTES(xdr, (uint8_t *)auth->oa_base, auth->oa_length)));
+}
+
+void xdr_free(xdrproc_t proc, char *objp)
+{
+    XDR x;
+    x.x_op = XDR_FREE;
+    (*proc)(&x, objp);
+}
diff --git a/librpc/rpc/clnt.h b/librpc/rpc/clnt.h
new file mode 100755
index 0000000..9d778af
--- /dev/null
+++ b/librpc/rpc/clnt.h
@@ -0,0 +1,224 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/*
+ * clnt.h - Client side remote procedure call interface.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+#ifndef _RPC_CLNT_H
+#define _RPC_CLNT_H 1
+
+
+/*
+ * By convention, procedure 0 takes null arguments and returns them
+ */
+#define NULLPROC ((u_long)0)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/time.h>
+
+/*
+ * Rpc calls return an enum clnt_stat.  This should be looked at more,
+ * since each implementation is required to live with this (implementation
+ * independent) list of errors.
+ */
+enum clnt_stat {
+  RPC_SUCCESS=0,      /* call succeeded */
+  /*
+   * local errors
+   */
+  RPC_CANTENCODEARGS=1,    /* can't encode arguments */
+  RPC_CANTDECODERES=2,    /* can't decode results */
+  RPC_CANTSEND=3,      /* failure in sending call */
+  RPC_CANTRECV=4,      /* failure in receiving result */
+  RPC_TIMEDOUT=5,      /* call timed out */
+  /*
+   * remote errors
+   */
+  RPC_VERSMISMATCH=6,    /* rpc versions not compatible */
+  RPC_AUTHERROR=7,    /* authentication error */
+  RPC_PROGUNAVAIL=8,    /* program not available */
+  RPC_PROGVERSMISMATCH=9,    /* program version mismatched */
+  RPC_PROCUNAVAIL=10,    /* procedure unavailable */
+  RPC_CANTDECODEARGS=11,    /* decode arguments error */
+  RPC_SYSTEMERROR=12,    /* generic "other problem" */
+  RPC_NOBROADCAST = 21,    /* Broadcasting not supported */
+  /*
+   * callrpc & clnt_create errors
+   */
+  RPC_UNKNOWNHOST=13,    /* unknown host name */
+  RPC_UNKNOWNPROTO=17,    /* unknown protocol */
+  RPC_UNKNOWNADDR = 19,    /* Remote address unknown */
+
+  /*
+   * rpcbind errors
+   */
+  RPC_RPCBFAILURE=14,    /* portmapper failed in its call */
+#define RPC_PMAPFAILURE RPC_RPCBFAILURE
+  RPC_PROGNOTREGISTERED=15,  /* remote program is not registered */
+  RPC_N2AXLATEFAILURE = 22,  /* Name to addr translation failed */
+  /*
+   * unspecified error
+   */
+  RPC_FAILED=16,
+  RPC_INTR=18,
+  RPC_TLIERROR=20,
+  RPC_UDERROR=23,
+  /*
+   * asynchronous errors
+   */
+  RPC_INPROGRESS = 24,
+  RPC_STALERACHANDLE = 25
+};
+
+struct CLIENT;
+typedef struct CLIENT CLIENT;
+/* client call callback. 
+ * Callback called when the reply is recieved or there is an error in
+ * getting reply.
+ */
+typedef void (*clnt_call_cb)
+( 
+  CLIENT * clnt, 
+  void * cookie, 
+  caddr_t results, 
+  rpc_reply_header error
+);
+
+typedef void (*clnt_call_non_blocking_cb)
+( 
+  CLIENT * clnt, 
+  void * cookie, 
+  caddr_t results, 
+  rpc_reply_header error
+);
+
+/*
+ * By convention, procedure 0 takes null arguments and returns them
+ */
+#define NULLPROC ((rpcproc_t)0)
+
+/*===========================================================================
+FUNCTION CLNT_CALL
+
+DESCRIPTION
+  RPCGEN support routine. This routine is called by client routines generated
+  by RPCGEN. It generates and sends an RPC message to a server.
+
+  This is a blocking call.   
+
+DEPENDENCIES
+  None.
+
+ARGUMENTS
+  xdr - the XDR to use to send the RPC message
+  proc - the server procedure to call
+  xdr_args - function pointer for encoding the RPC message args
+  args_ptr - pointer to args data structure
+  xdr_results - function pointer for decoding the RPC response
+  rets_ptr - pointer to results data structure
+  timeout - return after timeout (ignored)
+
+RETURN VALUE
+  RPC_SUCCESS - if successful
+  error code otherwise
+
+SIDE EFFECTS
+  None.
+===========================================================================*/
+extern enum clnt_stat 
+clnt_call
+( 
+  CLIENT *h, 
+  u_long proc,
+  xdrproc_t xdr_args,
+  caddr_t args_ptr,
+  xdrproc_t xdr_results, 
+  caddr_t rets_ptr,
+  struct timeval timeout
+);
+
+/*===========================================================================
+FUNCTION CLNT_CALL_NON_BLOCKING
+
+DESCRIPTION
+  RPCGEN support routine. This routine is called by client routines generated
+  by RPCGEN. It generates and sends an RPC message to a server.
+
+  This is a non-blocking call. It registers clnt_call_callback to be called
+  when the RPC response is received.
+  
+DEPENDENCIES
+  None.
+
+ARGUMENTS
+  xdr - the XDR to use to send the RPC message
+  proc - the server procedure to call
+  xdr_args - function pointer for encoding the RPC message args
+  args_ptr - pointer to args data structure
+  xdr_results - function pointer for decoding the RPC response
+  results_size - size of the results data structure
+  result_cb - function pointer to be called with the results
+  cb_data - cookie for results call back function
+
+RETURN VALUE
+  RPC_SUCCESS - if successful
+  error code otherwise
+
+SIDE EFFECTS
+  None.
+===========================================================================*/
+extern enum clnt_stat 
+clnt_call_non_blocking
+( 
+  CLIENT *h,
+  u_long proc,
+  xdrproc_t xdr_args,
+  caddr_t args_ptr,
+  xdrproc_t xdr_results,
+  int results_size,
+  clnt_call_cb result_cb,
+  void * cb_data
+);
+
+extern bool_t clnt_freeres( CLIENT *xdr, xdrproc_t xdr_res, caddr_t res_ptr );
+extern void clnt_destroy( CLIENT *xdr );
+extern CLIENT * clnt_create ( char * host, uint32 prog, uint32 vers,
+                              char * proto);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* rpc/clnt.h */
diff --git a/librpc/rpc/pmap_clnt.h b/librpc/rpc/pmap_clnt.h
new file mode 100755
index 0000000..7233dcb
--- /dev/null
+++ b/librpc/rpc/pmap_clnt.h
@@ -0,0 +1,53 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/*
+ * pmap_clnt.h
+ * Supplies C routines to get to portmap services.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+#ifndef PMAP_CLIENT_H
+#define PMAP_CLIENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+#include <rpc/clnt.h>
+#include <rpc/svc.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*PMAP_CLIENT_H*/
diff --git a/librpc/rpc/rpc.h b/librpc/rpc/rpc.h
new file mode 100755
index 0000000..2a9e716
--- /dev/null
+++ b/librpc/rpc/rpc.h
@@ -0,0 +1,53 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/*
+ * rpc.h, Just includes the billions of rpc header files necessary to
+ * do remote procedure calling.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+#ifndef RPC_H
+#define RPC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+#include <rpc/clnt.h>
+#include <rpc/svc.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* RPC_H */
diff --git a/librpc/rpc/rpc_router_ioctl.h b/librpc/rpc/rpc_router_ioctl.h
new file mode 100755
index 0000000..4d19a2a
--- /dev/null
+++ b/librpc/rpc/rpc_router_ioctl.h
@@ -0,0 +1,45 @@
+/*
+** Copyright 2008, Google Inc.
+** Copyright (c) 2009, Code Aurora Forum.All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
+**
+**     http://www.apache.org/licenses/LICENSE-2.0 
+**
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
+** limitations under the License.
+*/
+
+#ifndef RPC_IOCTL_H
+#define RPC_IOCTL_H
+
+#include <linux/ioctl.h>
+
+struct rpcrouter_ioctl_server_args {
+        uint32_t prog;
+        uint32_t vers;
+};
+
+#define RPC_ROUTER_IOCTL_MAGIC (0xC1)
+
+#define RPC_ROUTER_IOCTL_GET_VERSION \
+        _IOR(RPC_ROUTER_IOCTL_MAGIC, 0, unsigned int)
+
+#define RPC_ROUTER_IOCTL_GET_MTU \
+        _IOR(RPC_ROUTER_IOCTL_MAGIC, 1, unsigned int)
+
+#define RPC_ROUTER_IOCTL_REGISTER_SERVER \
+        _IOWR(RPC_ROUTER_IOCTL_MAGIC, 2, unsigned int)
+
+#define RPC_ROUTER_IOCTL_UNREGISTER_SERVER \
+        _IOWR(RPC_ROUTER_IOCTL_MAGIC, 3, unsigned int)
+
+#define RPC_ROUTER_IOCTL_CLEAR_NETRESET \
+  _IOWR(RPC_ROUTER_IOCTL_MAGIC, 4, unsigned int)
+
+#endif /* RPC_IOCTL_H */
diff --git a/librpc/rpc/svc.h b/librpc/rpc/svc.h
new file mode 100755
index 0000000..1421835
--- /dev/null
+++ b/librpc/rpc/svc.h
@@ -0,0 +1,220 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/*
+ * svc.h, Server-side remote procedure call interface.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+#ifndef _RPC_SVC_H
+#define _RPC_SVC_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <rpc/types.h>
+
+/*
+ * This interface must manage two items concerning remote procedure calling:
+ *
+ * 1) An arbitrary number of transport connections upon which rpc requests
+ * are received.  The two most notable transports are TCP and UDP;  they are
+ * created and registered by routines in svc_tcp.c and svc_udp.c, respectively;
+ * they in turn call xprt_register and xprt_unregister.
+ *
+ * 2) An arbitrary number of locally registered services.  Services are
+ * described by the following four data: program number, version number,
+ * "service dispatch" function, a transport handle, and a bool_t that
+ * indicates whether or not the exported program should be registered with a
+ * local binder service;  if true the program's number and version and the
+ * port number from the transport handle are registered with the binder.
+ * These data are registered with the rpc svc system via svc_register.
+ *
+ * A service's dispatch function is called whenever an rpc request comes in
+ * on a transport.  The request's program and version numbers must match
+ * those of the registered service.  The dispatch function is passed two
+ * parameters, struct svc_req * and SVCXPRT *, defined below.
+ */
+
+/*
+ * Server side transport handle
+ */
+struct SVCXPRT;
+typedef struct SVCXPRT SVCXPRT;
+
+/*
+ * Service request
+ */
+struct svc_req {
+  rpcprog_t rq_prog;            /* service program number */
+  rpcvers_t rq_vers;            /* service protocol version */
+  rpcproc_t rq_proc;            /* the desired procedure */
+  SVCXPRT *rq_xprt;             /* associated transport */
+};
+
+#ifndef __DISPATCH_FN_T
+#define __DISPATCH_FN_T
+typedef void (*__dispatch_fn_t) (struct svc_req*, SVCXPRT*);
+#endif
+
+/*
+ * Transport registration.
+ *
+ * xprt_register(xprt)
+ *      SVCXPRT *xprt;
+ */
+extern void xprt_register (SVCXPRT *__xprt);
+
+/*
+ * Transport un-register
+ *
+ * xprt_unregister(xprt)
+ *      SVCXPRT *xprt;
+ */
+extern void xprt_unregister (SVCXPRT *__xprt);
+
+/*
+ * Service registration (registers only with plugger module)
+ *
+ * svc_register_with_plugger(xprt, prog, vers, dispatch, protocol)
+ *	SVCXPRT *xprt;
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ *	void (*dispatch)(struct svc_req*, SVCXPRT*);
+ *	rpcprot_t protocol;  like TCP or UDP, zero means do not register
+ */
+extern bool_t svc_register_with_plugger (SVCXPRT *__xprt, rpcprog_t __prog,
+                                         rpcvers_t __vers,
+                                         __dispatch_fn_t __dispatch,
+                                         rpcprot_t __protocol);
+
+/*
+ * Service registration (registers with plugger module and lower layers)
+ *
+ * svc_register(xprt, prog, vers, dispatch, protocol)
+ *	SVCXPRT *xprt;
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ *	void (*dispatch)(struct svc_req*, SVCXPRT*);
+ *	rpcprot_t protocol;  like TCP or UDP, zero means do not register
+ */
+extern bool_t svc_register (SVCXPRT *__xprt, rpcprog_t __prog,
+                            rpcvers_t __vers, __dispatch_fn_t __dispatch,
+                            rpcprot_t __protocol);
+
+extern void svc_destroy(SVCXPRT *xprt);
+
+/*
+ * Service un-registration
+ *
+ * svc_unregister(xprt, prog, vers)
+ *  SVCXPRT *xprt
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ */
+void
+svc_unregister (SVCXPRT *__xprt, rpcprog_t prog, rpcvers_t vers);
+
+/*
+ * Service Enable
+ *
+ * svc_enable( prog, vers )
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ */
+#define svc_enable(prog, vers) svc_lock(prog, vers, FALSE)
+
+/*
+ * Service Disable
+ *
+ * svc_disable( prog, vers )
+ *	rpcprog_t prog;
+ *	rpcvers_t vers;
+ */
+#define svc_disable(prog, vers) svc_lock(prog, vers, TRUE)
+
+extern void svc_lock(rpcprog_t __prog, rpcvers_t __vers, bool_t __lock);
+
+/*
+ * When the service routine is called, it must first check to see if it
+ * knows about the procedure;  if not, it should call svcerr_noproc
+ * and return.  If so, it should deserialize its arguments via
+ * SVC_GETARGS (defined above).  If the deserialization does not work,
+ * svcerr_decode should be called followed by a return.  Successful
+ * decoding of the arguments should be followed the execution of the
+ * procedure's code and a call to svc_sendreply.
+ *
+ * Also, if the service refuses to execute the procedure due to too-
+ * weak authentication parameters, svcerr_weakauth should be called.
+ * Note: do not confuse access-control failure with weak authentication!
+ *
+ * NB: In pure implementations of rpc, the caller always waits for a reply
+ * msg.  This message is sent when svc_sendreply is called.
+ * Therefore pure service implementations should always call
+ * svc_sendreply even if the function logically returns void;  use
+ * xdr.h - xdr_void for the xdr routine.  HOWEVER, tcp based rpc allows
+ * for the abuse of pure rpc via batched calling or pipelining.  In the
+ * case of a batched call, svc_sendreply should NOT be called since
+ * this would send a return message, which is what batching tries to avoid.
+ * It is the service/protocol writer's responsibility to know which calls are
+ * batched and which are not.  Warning: responding to batch calls may
+ * deadlock the caller and server processes!
+ */
+
+extern bool_t svc_getargs(SVCXPRT *xdr, xdrproc_t xdr_args, caddr_t args_ptr);
+extern bool_t svc_freeargs(SVCXPRT *xdr, xdrproc_t xdr_args, caddr_t args_ptr);
+
+extern bool_t	svc_sendreply (SVCXPRT *xprt, xdrproc_t __xdr_results,
+			       caddr_t __xdr_location);
+
+/*
+ * Socket to use on svcxxx_create call to get default socket
+ */
+#define	RPC_ANYSOCK	-1
+
+/* 
+ * Router based rpc.
+ */
+extern SVCXPRT *svcrtr_create (void);
+
+extern void svcerr_decode (SVCXPRT *);
+extern void svcerr_weakauth (SVCXPRT *);
+extern void svcerr_noproc (SVCXPRT *);
+extern void svcerr_noprog (SVCXPRT *);
+extern void svcerr_systemerr (SVCXPRT *);
+extern void svcerr_progvers (SVCXPRT *, rpcvers_t __low_vers, rpcvers_t __high_vers);
+extern void svcerr_auth (SVCXPRT *, auth_stat __why);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* rpc/svc.h */
diff --git a/librpc/rpc/types.h b/librpc/rpc/types.h
new file mode 100755
index 0000000..e41e0f3
--- /dev/null
+++ b/librpc/rpc/types.h
@@ -0,0 +1,437 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/* fixincludes should not add extern "C" to this file */
+/*
+ * Rpc additions to <sys/types.h>
+ */
+
+#ifndef RPCXDRTYPES_H
+#define RPCXDRTYPES_H
+
+/*
+ * XDR provides a conventional way for converting between C data
+ * types and an external bit-string representation.  Library supplied
+ * routines provide for the conversion on built-in C data types.  These
+ * routines and utility routines defined here are used to help implement
+ * a type encode/decode routine for each user-defined type.
+ *
+ * Each data type provides a single procedure which takes two arguments:
+ *
+ *      bool_t
+ *      xdrproc(xdrs, argresp)
+ *              XDR *xdrs;
+ *              <type> *argresp;
+ *
+ * xdrs is an instance of a XDR handle, to which or from which the data
+ * type is to be converted.  argresp is a pointer to the structure to be
+ * converted.  The XDR handle contains an operation field which indicates
+ * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
+ *
+ * XDR_DECODE may allocate space if the pointer argresp is null.  This
+ * data can be freed with the XDR_FREE operation.
+ *
+ * We write only one procedure per data type to make it easy
+ * to keep the encode and decode procedures for a data type consistent.
+ * In many cases the same code performs all operations on a user defined type,
+ * because all the hard work is done in the component type routines.
+ * decode as a series of calls on the nested data types.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The version of ONCRPC supported */
+#define RPC_MSG_VERSION    ((u_long) 2)
+
+#include <inttypes.h>
+#include <string.h>
+#include <pthread.h>
+
+typedef int bool_t; /* This has to be a long, as it is used for XDR boolean too, which is a 4-byte value */
+typedef unsigned long rpcprog_t;
+typedef unsigned long rpcproc_t;
+typedef unsigned long rpcvers_t;
+typedef unsigned long rpcprot_t;
+typedef uint64_t uint64;
+typedef uint32_t uint32;
+typedef uint16_t uint16;
+typedef uint8_t  uint8;
+typedef int32_t  int32;
+typedef int16_t  int16;
+typedef int8_t   int8;
+typedef int32_t  enum_t;
+typedef int64_t  quad_t;
+typedef uint64_t u_quad_t;
+//typedef uint16_t u_short; /* defined in kernel_headers */
+#define TRUE 1
+#define FALSE 0
+static inline void* mem_alloc(size_t size) { return malloc(size); }
+static inline void mem_free(void* ptr) { free(ptr); }
+
+/*
+ * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
+ * stream.  XDR_DECODE causes the type to be extracted from the stream.
+ * XDR_FREE can be used to release the space allocated by an XDR_DECODE
+ * request.
+ */
+enum xdr_op {
+  XDR_ENCODE = 0,
+  XDR_DECODE = 1,
+  XDR_FREE = 2
+};
+
+/*
+ * This is the number of bytes per unit of external data.
+ */
+#define BYTES_PER_XDR_UNIT  (4)
+
+/*
+ * The XDR handle.
+ * Contains operation which is being applied to the stream,
+ * an operations vector for the particular implementation (e.g. see xdr_mem.c),
+ * and two private fields for the use of the particular implementation.
+ */
+typedef struct xdr_struct XDR;
+/*
+ * A xdrproc_t exists for each data type which is to be encoded or decoded.
+ *
+ * The second argument to the xdrproc_t is a pointer to an opaque pointer.
+ * The opaque pointer generally points to a structure of the data type
+ * to be decoded.  If this pointer is 0, then the type routines should
+ * allocate dynamic storage of the appropriate size and return it.
+ * bool_t       (*xdrproc_t)(XDR *, caddr_t *);
+ */
+typedef bool_t (*xdrproc_t) (XDR *, void *,...);
+
+
+#define ONCRPC_CONTROL_GET_MTU                (1)
+#define ONCRPC_CONTROL_GET_TX_QUOTA           (2)
+#define ONCRPC_CONTROL_GET_RX_BUFFER_SIZE     (3)
+#define ONCRPC_CONTROL_REGISTER_SERVER        (4)
+#define ONCRPC_CONTROL_UNREGISTER_SERVER      (5)
+#define ONCRPC_CONTROL_GET_DEST               (6)
+#define ONCRPC_CONTROL_OPEN_XPORT             (7)
+#define ONCRPC_CONTROL_CLOSE_XPORT            (8)
+#define ONCRPC_CONTROL_SET_DEST               (9)
+#define ONCRPC_CONTROL_GET_SOURCE_ADDR        (10)
+
+typedef struct oncrpc_prog_ver_struct
+{
+  rpcprog_t prog;
+  rpcvers_t ver;
+  void (*dispatch)();
+} oncrpc_prog_ver_type;
+
+typedef uint64  oncrpc_addr_type;
+
+typedef struct {
+  oncrpc_addr_type        addr;
+  oncrpc_prog_ver_type    prog_ver;
+} oncrpc_control_get_dest_type;
+
+typedef struct {
+  oncrpc_addr_type        addr;  
+} oncrpc_control_get_source_type;
+
+typedef struct{
+  oncrpc_prog_ver_type   prog_ver;
+} oncrpc_control_register_server_type;
+
+typedef struct{
+  oncrpc_prog_ver_type   prog_ver;
+} oncrpc_control_unregister_server_type;
+
+typedef struct{
+  oncrpc_addr_type  dest;
+} oncrpc_control_set_dest_type;
+
+typedef struct{
+  unsigned int xp;
+  unsigned int port;
+} oncrpc_control_open_xport_type;
+
+#define NULL_xdrproc_t ((xdrproc_t)0)
+
+/*
+ * Support struct for discriminated unions.
+ * You create an array of xdrdiscrim structures, terminated with
+ * a entry with a null procedure pointer.  The xdr_union routine gets
+ * the discriminant value and then searches the array of structures
+ * for a matching value.  If a match is found the associated xdr routine
+ * is called to handle that part of the union.  If there is
+ * no match, then a default routine may be called.
+ * If there is no match and no default routine it is an error.
+ */
+struct xdr_discrim
+{
+  int value;
+  xdrproc_t proc;
+};
+
+/* Message enums */
+typedef enum {
+  RPC_MSG_CALL=0,
+  RPC_MSG_REPLY=1,
+  RPC_MSG_UNDEF = 2,
+} rpc_msg_e_type;
+
+typedef enum {
+  RPC_MSG_ACCEPTED=0,
+  RPC_MSG_DENIED=1
+} rpc_reply_stat_e_type;
+
+typedef enum {
+  RPC_ACCEPT_SUCCESS = 0,
+  RPC_PROG_UNAVAIL   = 1,
+  RPC_PROG_MISMATCH  = 2,
+  RPC_PROC_UNAVAIL   = 3,
+  RPC_GARBAGE_ARGS   = 4,
+  RPC_SYSTEM_ERR     = 5,
+  RPC_PROG_LOCKED    = 6
+} rpc_accept_stat_e_type;
+
+typedef enum {
+  RPC_MISMATCH=0,
+  RPC_AUTH_ERROR=1
+} rpc_reject_stat_e_type ;
+
+/* Auth types */
+
+/*
+ * Status returned from authentication check
+ */
+typedef enum {
+  AUTH_OK=0,
+  /*
+   * failed at remote end
+   */
+  AUTH_BADCRED=1,       /* bogus credentials (seal broken) */
+  AUTH_REJECTEDCRED=2,  /* client should begin new session */
+  AUTH_BADVERF=3,       /* bogus verifier (seal broken) */
+  AUTH_REJECTEDVERF=4,  /* verifier expired or was replayed */
+  AUTH_TOOWEAK=5,       /* rejected due to security reasons */
+  /*
+   * failed locally
+   */
+  AUTH_INVALIDRESP=6,   /* bogus response verifier */
+  AUTH_FAILED=7         /* some unknown reason */
+} auth_stat;
+
+typedef enum {
+  AUTH_NONE  =0,   /* no authentication */
+  AUTH_NULL  =0,   /* backward compatibility */
+  AUTH_SYS   =1,   /* unix style (uid, gids) */
+  AUTH_UNIX  =1, 
+  AUTH_SHORT =2    /* short hand unix style */
+} oncrpc_auth_types;
+/*
+ * Authentication info.  Opaque to client.
+ */
+typedef struct opaque_auth {
+  oncrpc_auth_types oa_flavor;    /* flavor of auth */
+  caddr_t           oa_base;      /* address of more auth stuff */
+  u_int             oa_length;    /* not to exceed MAX_AUTH_BYTES */
+} opaque_auth;
+
+#define MAX_AUTH_BYTES  400
+#define MAXNETNAMELEN   255  /* maximum length of network user's name */
+
+/* Error types */
+/*
+ * Reply header to an rpc request that was accepted by the server.
+ * Note: there could be an error even though the request was
+ * accepted.
+ */
+struct rpc_accepted_reply_header
+{
+  opaque_auth              verf;
+  rpc_accept_stat_e_type   stat;
+  union
+  {
+    struct
+    {
+      uint32 low;
+      uint32 high;
+    } versions;
+  } u;
+};
+
+/*
+ * Reply to an rpc request that was denied by the server.
+ */
+struct rpc_denied_reply
+{
+  rpc_reject_stat_e_type stat;
+  union
+  {
+    struct
+    {
+      uint32 low;
+      uint32 high;
+    } versions;
+    auth_stat why;  /* why authentication did not work */
+  } u;
+};
+
+/*
+ * RPC reply header structure. The reply header contains error codes in
+ * case of errors in the server side or the RPC call being rejected.
+ */
+typedef struct rpc_reply_header
+{
+  rpc_reply_stat_e_type stat;
+  union
+  {
+    struct rpc_accepted_reply_header ar;
+    struct rpc_denied_reply dr;
+  } u;
+} rpc_reply_header;
+
+/* XDR memory wrapper structure */
+typedef struct oncrpcxdr_mem_struct {
+  struct oncrpcxdr_mem_struct *next;
+
+#ifdef IMAGE_APPS_PROC
+  /* make structure size 8-bytes so we
+     keep 8-byte alignment */
+  uint32 padding;
+#endif
+} oncrpcxdr_mem_s_type;
+
+// TODO - keep XPORT objects on queue to help track down memory leaks
+
+/*===========================================================================
+  Defining the XPORT structure
+  ===========================================================================*/
+
+#define XPORT_FLAG_XPORT_ALLOCED        0x0001
+
+/*===========================================================================
+  Defining the XDR structure
+  ===========================================================================*/
+
+typedef struct xdr_struct xdr_s_type;
+
+/* Call back definition for non-blocking RPC calls */
+typedef void (*rpc_reply_cb_type)(xdr_s_type *xdr, void *data);
+
+/* Entry points that must be provided by xdr */
+struct xdr_ops_struct {
+  /* Transport control functions */
+  void        (*xdr_destroy) (xdr_s_type *xdr);
+  bool_t      (*xdr_control) (xdr_s_type *xdr, int request, void *info);
+
+  /* Incoming message control functions */
+  bool_t (*read)           (xdr_s_type *xdr);
+  bool_t (*msg_done)       (xdr_s_type *xdr);
+
+  /* Outgoing message control functions */
+  bool_t (*msg_start) (xdr_s_type *xdr, rpc_msg_e_type rpc_msg_type);
+  bool_t (*msg_abort) (xdr_s_type *xdr);
+  bool_t (*msg_send)  (xdr_s_type *xdr);
+  
+  /* Message data functions */
+  bool_t (*send_int8)   (xdr_s_type *xdr, const int8 *value);
+  bool_t (*send_uint8)  (xdr_s_type *xdr, const uint8 *value);
+  bool_t (*send_int16)  (xdr_s_type *xdr, const int16 *value);
+  bool_t (*send_uint16) (xdr_s_type *xdr, const uint16 *value);
+  bool_t (*send_int32)  (xdr_s_type *xdr, const int32 *value);
+  bool_t (*send_uint32) (xdr_s_type *xdr, const uint32 *value);
+  bool_t (*send_bytes)  (xdr_s_type *xdr, const uint8 *buf, uint32 len);
+
+  bool_t (*recv_int8)   (xdr_s_type *xdr, int8 *value);
+  bool_t (*recv_uint8)  (xdr_s_type *xdr, uint8 *value);
+  bool_t (*recv_int16)  (xdr_s_type *xdr, int16 *value);
+  bool_t (*recv_uint16) (xdr_s_type *xdr, uint16 *value);
+  bool_t (*recv_int32)  (xdr_s_type *xdr, int32 *value);
+  bool_t (*recv_uint32) (xdr_s_type *xdr, uint32 *value);
+  bool_t (*recv_bytes)  (xdr_s_type *xdr, uint8 *buf, uint32 len);
+};
+
+typedef struct xdr_ops_struct xdr_ops_s_type;
+
+/*===========================================================================
+  XDR structure definition - provides a generic interface to each
+  supported transport. The xdr structure is used both for clients and
+  for servers.
+  ===========================================================================*/
+
+#define RPCROUTER_MSGSIZE_MAX (18432)
+
+struct xdr_struct {
+  const xdr_ops_s_type      *xops;
+  enum xdr_op                x_op;           /* used for ENCODE and DECODE */
+  uint32                     x_prog;         /* program number */
+  uint32                     x_vers;         /* program version */
+  uint32                     x_proc;         /* for debug output */
+
+  opaque_auth                verf;           /* verf to send back */
+  uint32                     xid;
+  int                        fd;
+  int                        is_client;
+
+  /* RPC-call message (if XDR is a client) or RPC-reply message (if
+     XDR is a server). */
+
+  uint8                      out_msg[RPCROUTER_MSGSIZE_MAX];
+  int                        out_next;
+
+  /* Reply message or incoming-call message.  For a client XDR, this
+     buffer always contains the reply received in response to an RPC
+     call.  For a server XDR, this buffer always contains an incoming
+     RPC call.
+  */
+  uint8                      in_msg[RPCROUTER_MSGSIZE_MAX];
+  int                        in_next;
+  int                        in_len;
+};
+
+// Transport flag definitions
+#define XDR_FLAG_XDR_ALLOCED        0x0001
+#define XDR_FLAG_DEDICATED          0x0002
+#define XDR_FLAG_DESTROYING         0x0004
+#define XDR_FLAG_RETRY              0x0008
+
+
+/// @todo FIXME this goes with the callback stuff in oncrpcxdr.c. Move
+/// elsewhere and pick better symbol names.
+typedef struct rpc_cb_data_type {
+  void                     * cb_handler;
+  uint32                     cb_id;
+  rpcprot_t                  protocol;
+  oncrpc_addr_type           cb_source;
+} rpc_cb_data_type;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _RPC_XDR_TYPES_H */
diff --git a/librpc/rpc/xdr.h b/librpc/rpc/xdr.h
new file mode 100755
index 0000000..6f69381
--- /dev/null
+++ b/librpc/rpc/xdr.h
@@ -0,0 +1,115 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+/*
+ * xdr.h, External Data Representation Serialization Routines.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+#ifndef XDR_H
+#define XDR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*===========================================================================
+  Macros for calling primitive XDR routines (this is independent of RPC)
+  ===========================================================================*/
+
+#define XDR_RECV_BYTES(XDR, BUF, LEN) (XDR)->xops->recv_bytes(XDR, BUF, LEN)
+#define XDR_RECV_INT16(XDR, VALUE)    (XDR)->xops->recv_int16(XDR, VALUE)
+#define XDR_RECV_INT32(XDR, VALUE)    (XDR)->xops->recv_int32(XDR, VALUE)
+#define XDR_RECV_INT8(XDR, VALUE)     (XDR)->xops->recv_int8(XDR, VALUE)
+#define XDR_RECV_UINT(XDR, VALUE)     (XDR)->xops->recv_uint32(XDR, (uint32 *)(VALUE))
+#define XDR_RECV_UINT32(XDR, VALUE)   (XDR)->xops->recv_uint32(XDR, VALUE)
+#define XDR_SEND_BYTES(XDR, BUF, LEN) (XDR)->xops->send_bytes(XDR, BUF, LEN)
+#define XDR_SEND_INT16(XDR, VALUE)    (XDR)->xops->send_int16(XDR, VALUE)
+#define XDR_SEND_INT32(XDR, VALUE)    (XDR)->xops->send_int32(XDR, VALUE)
+#define XDR_SEND_INT8(XDR, VALUE)     (XDR)->xops->send_int8(XDR, VALUE)
+#define XDR_SEND_UINT(XDR, VALUE)     (XDR)->xops->send_uint32(XDR, (uint32 *)(VALUE))
+#define XDR_SEND_UINT32(XDR, VALUE)   (XDR)->xops->send_uint32(XDR, VALUE)
+
+/*===========================================================================
+  Macros for sending and receiving an RPC message through the transport
+  ===========================================================================*/
+
+#define XDR_MSG_START(XDR, TYPE)      (XDR)->xops->msg_start(XDR, TYPE)
+#define XDR_MSG_SEND(XDR)             (XDR)->xops->msg_send(XDR)
+#define XDR_MSG_DONE(XDR)             (XDR)->xops->msg_done(XDR)
+#define XDR_MSG_ABORT(XDR)            (XDR)->xops->msg_abort(XDR)
+
+extern bool_t xdr_call_msg_start (XDR *xdr, uint32 prog, uint32 ver, uint32 proc, opaque_auth *cred, opaque_auth *verf);
+extern bool_t xdr_reply_msg_start (XDR *xdr, opaque_auth *verf);
+extern bool_t xdr_send_auth (XDR *xdr, const opaque_auth *auth);
+extern bool_t xdr_send_reply_header (XDR *xdr, rpc_reply_header const *reply);
+extern void   xdr_free (xdrproc_t proc, char *objp);
+
+/***********************************************************************
+        Support for rpcgen
+ ***********************************************************************/
+
+#define XDR_SEND_ENUM(XDR, VALUE) xdr_send_enum(XDR, (void *) (VALUE), sizeof(*(VALUE)))
+#define XDR_RECV_ENUM(XDR, VALUE) xdr_recv_enum(XDR, (void *) (VALUE), sizeof(*(VALUE)))
+extern bool_t xdr_send_enum (XDR *xdr, const void *value, uint32 size);
+extern bool_t xdr_recv_enum (XDR *xdr, void *value, uint32 size);
+
+extern bool_t xdr_bytes (XDR *xdr, char **cpp, u_int *sizep, u_int maxsize);
+extern bool_t xdr_enum (XDR *xdr, enum_t *ep);
+extern bool_t xdr_pointer (XDR *xdrs, char **_objpp, u_int obj_size, xdrproc_t xdr_obj);
+extern bool_t xdr_int (XDR *xdr, int *ip);
+extern bool_t xdr_u_int (XDR *xdr, u_int *ip);
+extern bool_t xdr_char (XDR *xdr, char *cp);
+extern bool_t xdr_u_char (XDR *xdr, u_char *cp);
+extern bool_t xdr_long (XDR *xdr, long *ulp);
+extern bool_t xdr_u_long (XDR *xdr, u_long *ulp);
+#define xdr_uint32 xdr_u_long
+extern bool_t xdr_quad_t (XDR *xdrs, quad_t *llp);
+extern bool_t xdr_u_quad_t (XDR *__xdrs, u_quad_t *__ullp);
+extern bool_t xdr_short (XDR *xdr, short *sp);
+extern bool_t xdr_u_short (XDR *xdr, u_short *usp);
+extern bool_t xdr_vector (XDR *xdrs, char *basep, u_int nelem, u_int elemsize, xdrproc_t xdr_elem);
+extern bool_t xdr_void (void);
+extern bool_t xdr_opaque (XDR *xdr, caddr_t cp, u_int cnt);
+extern bool_t xdr_string (XDR *xdr, char **cpp, u_int maxsize);
+
+extern bool_t xdr_array (
+    XDR *xdrs,
+    caddr_t *addrp,/* array pointer */
+    u_int *sizep,  /* number of elements */
+    u_int maxsize,  /* max numberof elements */
+    u_int elsize,  /* size in bytes of each element */
+    xdrproc_t elproc); /* xdr routine to handle each element */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* rpc/xdr.h */
diff --git a/librpc/svc.c b/librpc/svc.c
new file mode 100755
index 0000000..a301369
--- /dev/null
+++ b/librpc/svc.c
@@ -0,0 +1,577 @@
+/* Parts of this file are derived from the original Sun (ONC) RPC
+ * code, under the following copyright:
+ */
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+/*
+ * svc.c, Server-side remote procedure call interface.
+ *
+ * There are two sets of procedures here.  The xprt routines are
+ * for handling transport handles.  The svc routines handle the
+ * list of service routines.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ */
+
+/* Copyright (c) 2010, Code Aurora Forum. */
+
+#include <rpc/rpc.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <rpc/rpc_router_ioctl.h>
+#include <debug.h>
+#include <pthread.h>
+#include <stdlib.h>
+
+extern XDR *xdr_init_common(const char *name, int is_client);
+extern void xdr_destroy_common(XDR *xdr);
+extern int r_control(int handle, const uint32 cmd, void *arg);
+extern void grabPartialWakeLock();
+extern void releaseWakeLock();
+
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+typedef struct registered_server_struct {
+    /* MUST BE AT OFFSET ZERO!  The client code assumes this when it overwrites
+       the XDR for server entries which represent a callback client.  Those
+       server entries do not have their own XDRs.
+    */
+    XDR *xdr;
+    /* Because the xdr is NULL for callback clients (as opposed to true
+       servers), we keep track of the program number and version number in this
+       structure as well.
+    */       
+    rpcprog_t x_prog; /* program number */
+    rpcvers_t x_vers; /* program version */
+
+    int active;
+    struct registered_server_struct *next;
+    SVCXPRT *xprt;
+    __dispatch_fn_t dispatch;
+} registered_server;
+
+struct SVCXPRT {
+    fd_set fdset;
+    int max_fd;
+    pthread_attr_t thread_attr;
+    pthread_t  svc_thread;
+    pthread_mutexattr_t lock_attr;
+    pthread_mutex_t lock;
+    registered_server *servers;
+    int num_cb_servers;
+    volatile int num_servers;
+};
+
+static pthread_mutex_t xprt_lock = PTHREAD_MUTEX_INITIALIZER;
+int xprt_refcount;
+SVCXPRT *the_xprt; /* FIXME: have a list or something */
+
+/*
+  This routine is only of interest if a service implementor does not
+  call svc_run(), but instead implements custom asynchronous event
+  processing.  It is called when the select() system call has
+  determined that an RPC request has arrived on some RPC socket(s);
+  rdfds is the resultant read file descriptor bit mask.  The routine
+  returns when all sockets associated with the value of rdfds have
+  been serviced.
+ */
+
+void svc_dispatch(registered_server *svc, SVCXPRT *xprt);
+
+static void* svc_context(void *__u)
+{
+    SVCXPRT *xprt = (SVCXPRT *)__u;
+    int n;
+    struct timeval tv;
+    volatile fd_set rfds;
+    while(xprt->num_servers) {
+        rfds = xprt->fdset;
+        tv.tv_sec = 1; tv.tv_usec = 0;
+        n = select(xprt->max_fd + 1, (fd_set *)&rfds, NULL, NULL, &tv);
+        if (n < 0) {
+            E("select() error %s (%d)\n", strerror(errno), errno);
+            continue;
+        }
+        if (n) {
+            grabPartialWakeLock();
+            for (n = 0; n <= xprt->max_fd; n++) {
+                if (FD_ISSET(n, &rfds)) {
+                    /* the file descriptor points to the service instance; we
+                       simply look that service by its file descriptor, and
+                       call its service function. */
+                    /* FIXME: need to take xprt->lock */
+                    registered_server *trav = xprt->servers;
+                    for (; trav; trav = trav->next)
+		      if ((trav->xdr) && (trav->xdr->fd == n)) {
+                            /* read the entire RPC */
+                            if (trav->xdr->xops->read(trav->xdr) == 0) {
+                                E("%08x:%08x ONCRPC read error: aborting!\n",
+                                  trav->xdr->x_prog, trav->xdr->x_vers);
+                                abort();
+                            }
+                            svc_dispatch(trav, xprt);
+                            break;
+                        }
+                } /* if fd is set */
+            } /* for each fd */
+            releaseWakeLock();
+        }
+    }
+    D("RPC-server thread exiting!\n");
+    return NULL;
+}
+
+SVCXPRT *svcrtr_create (void)
+{
+    SVCXPRT *xprt;
+    pthread_mutex_lock(&xprt_lock);
+    if (the_xprt) {
+        D("The RPC transport has already been created.\n");
+        xprt = the_xprt;
+    } else {
+        xprt = calloc(1, sizeof(SVCXPRT));
+        if (xprt) {
+            FD_ZERO(&xprt->fdset);
+            xprt->max_fd = 0;
+            pthread_attr_init(&xprt->thread_attr);
+            pthread_attr_setdetachstate(&xprt->thread_attr,
+                                        PTHREAD_CREATE_DETACHED);
+            pthread_mutexattr_init(&xprt->lock_attr);
+//          pthread_mutexattr_settype(&xprt->lock_attr,
+//                                    PTHREAD_MUTEX_RECURSIVE);
+            pthread_mutex_init(&xprt->lock, &xprt->lock_attr);
+        }
+    }    
+    pthread_mutex_unlock(&xprt_lock);
+    return xprt;
+}
+
+void svc_destroy(SVCXPRT *xprt)
+{
+    /* the last call to xprt_unregister() does the job */
+}
+
+/* NOTE: this function must always be called with the xprt->lock held! */
+static registered_server* svc_find_nosync(SVCXPRT *xprt, 
+                                          rpcprog_t prog, rpcvers_t vers,
+                                          registered_server **prev)
+{
+    registered_server *trav;
+    trav = xprt->servers;
+    if (prev) *prev = NULL;
+    for (; trav; trav = trav->next) {
+        if (trav->x_prog == prog && trav->x_vers == vers)
+            break;
+        if (prev) *prev = trav;
+    }
+    return trav;
+}
+
+registered_server* svc_find(SVCXPRT *xprt, 
+                            rpcprog_t prog, rpcvers_t vers)
+{
+    pthread_mutex_lock(&xprt->lock);
+    registered_server *svc = svc_find_nosync(xprt, prog, vers, NULL);
+    pthread_mutex_unlock(&xprt->lock);
+    return svc;
+}
+
+bool_t svc_register (SVCXPRT *xprt, rpcprog_t prog, rpcvers_t vers, 
+                     __dispatch_fn_t dispatch,
+                     rpcprot_t protocol)
+{
+    struct rpcrouter_ioctl_server_args args;
+    registered_server* svc;
+
+    pthread_mutex_lock(&xprt->lock);
+
+    D("registering for service %08x:%d\n", (uint32_t)prog, (int)vers);
+
+    svc = svc_find_nosync(xprt, prog, vers, NULL);
+
+    if (svc) {
+        E("service is already registered!\n");
+        pthread_mutex_unlock(&xprt->lock);
+        return svc->dispatch == dispatch;
+    }
+
+    svc = malloc(sizeof(registered_server));
+
+    /* If the program number of the RPC server ANDs with 0x01000000, then it is
+       not a true RPC server, but a callback client for an existing RPC client.
+       For example, if you have an RPC client with the program number
+       0x30000000, then its callback client will have a program number
+       0x31000000.  RPC calls on program number 0x31000000 will arrive on the
+       RPC client 0x30000000.
+    */
+
+    if (prog & 0x01000000) {
+        D("RPC server %08x:%d is a callback client, "
+          "creating dummy service entry!\n", (uint32_t)prog, (int)vers);
+        svc->xdr = NULL;
+        svc->x_prog = prog;
+        svc->x_vers = vers;        
+    } else {
+        V("RPC server %08x:%d is a real server.\n", (uint32_t)prog, (int)vers);
+        svc->xdr = xdr_init_common("00000000:0", 0 /* not a client XDR */);
+        if (svc->xdr == NULL) {
+            E("failed to initialize service (permissions?)!\n");
+            free(svc);
+            pthread_mutex_unlock(&xprt->lock);
+            return FALSE;
+        }
+
+        args.prog = prog;
+        args.vers = vers;    
+        V("RPC server %08x:%d: registering with kernel.\n",
+          (uint32_t)prog, (int)vers);
+        if (r_control(svc->xdr->fd, 
+                      RPC_ROUTER_IOCTL_REGISTER_SERVER, 
+                      &args) < 0) {
+            E("ioctl(RPC_ROUTER_IOCTL_REGISTER_SERVER) failed: %s!\n",
+              strerror(errno));
+            xdr_destroy_common(svc->xdr);
+            free(svc);
+            pthread_mutex_unlock(&xprt->lock);
+            return FALSE;
+        }
+
+        FD_SET(svc->xdr->fd, &xprt->fdset);
+        if (svc->xdr->fd > xprt->max_fd) xprt->max_fd = svc->xdr->fd;
+        svc->x_prog = svc->xdr->x_prog = prog;
+        svc->x_vers = svc->xdr->x_vers = vers;        
+    }
+
+    svc->dispatch = dispatch;
+    svc->next = xprt->servers;
+    xprt->servers = svc;
+    if (svc->xdr)
+        xprt->num_servers++;
+    else
+        xprt->num_cb_servers++;
+
+    V("RPC server %08x:%d: after registering,"
+      "total %d servers, %d cb servers.\n",
+      (uint32_t)prog, (int)vers, xprt->num_servers, xprt->num_cb_servers);
+    svc->xprt = xprt;
+    if (xprt->num_servers == 1) {
+        D("creating RPC-server thread (detached)!\n");
+        pthread_create(&xprt->svc_thread,
+                       &xprt->thread_attr,
+                       svc_context, xprt);
+    }
+    pthread_mutex_unlock(&xprt->lock);
+    return TRUE;
+}
+
+void svc_unregister (SVCXPRT *xprt, rpcprog_t prog, rpcvers_t vers) {
+    registered_server *prev, *found;
+    pthread_mutex_lock(&xprt->lock);
+    found = svc_find_nosync(xprt, prog, vers, &prev);
+    D("unregistering RPC server %08x:%d\n", (unsigned)prog, (unsigned)vers);
+    if (found) {
+        struct rpcrouter_ioctl_server_args args;
+        if (prev) {
+            V("RPC server %08x:%d is not the first in the list\n", 
+              (unsigned)prog, (unsigned)vers);
+            prev->next = found->next;
+        } else {
+            V("RPC server %08x:%d the first in the list\n", 
+              (unsigned)prog, (unsigned)vers);
+            xprt->servers = found->next;
+        }
+
+        /* Is is an RPC server or a callback client? */
+        if (found->xdr) {
+            if (!(prog & 0x01000000)) {
+                V("RPC server %08x:%d is not a callback server.\n",
+                  (unsigned)prog, (unsigned)vers);
+                /* don't bother decreasing the xprt->max_fd to the previous
+                 * minimum.
+                 */
+                args.prog = prog;
+                args.vers = vers;    
+                if (r_control(found->xdr->fd,
+                              RPC_ROUTER_IOCTL_UNREGISTER_SERVER,
+                              &args) < 0) {
+                    E("ioctl(RPC_ROUTER_IOCTL_UNREGISTER_SERVER) "
+                      "failed: %s!\n", 
+                      strerror(errno));
+                }                
+                FD_CLR(found->xdr->fd, &xprt->fdset);
+            }
+            V("RPC server %08x:%d: destroying XDR\n",
+                   (unsigned)prog, (unsigned)vers);
+            xdr_destroy_common(found->xdr);
+        }
+        else V("RPC server %08x:%d does not have an associated XDR\n", 
+               (unsigned)prog, (unsigned)vers);
+
+        /* When this goes to zero, the RPC-server thread will exit.  We do not
+         * need to wait for the thread to exit, because it is detached.
+         */
+        if (found->xdr)
+            xprt->num_servers--;
+        else
+            xprt->num_cb_servers--;
+
+        free(found);
+        V("RPC server %08x:%d: after unregistering,"
+	  "%d servers, %d cb servers left.\n",
+          (unsigned)prog, (unsigned)vers,
+	  xprt->num_servers, xprt->num_cb_servers);
+    }
+    pthread_mutex_unlock(&xprt->lock);
+}
+
+/* 
+RPC_OFFSET + 
+0  00000000 RPC xid                 network-byte order
+1  00000000 RPC call 
+2  00000002 rpc version
+3  3000005d prog num
+4  00000000 prog vers
+5  00000001 proc num
+
+6  00000000 cred
+7  00000000 cred
+8  00000000 verf
+9  00000000 verf
+
+a  0001fcc1 parms...
+b  00354230 
+c  00000000
+ */
+
+void svc_dispatch(registered_server *svc, SVCXPRT *xprt)
+{
+    struct svc_req req;
+
+    /* Read enough of the packet to be able to find the program number, the
+       program-version number, and the procedure call.  Notice that anything
+       arriving on this channel must be an RPC call.  Also, the program and
+       program-version numbers must match what's in the XDR of the service. */
+
+    D("reading on fd %d for %08x:%d\n", 
+      svc->xdr->fd, svc->x_prog, svc->x_vers);
+
+    uint32 prog = ntohl(((uint32 *)(svc->xdr->in_msg))[RPC_OFFSET+3]);
+    uint32 vers = ntohl(((uint32 *)(svc->xdr->in_msg))[RPC_OFFSET+4]);
+    uint32 proc = ntohl(((uint32 *)(svc->xdr->in_msg))[RPC_OFFSET+5]);
+
+    if (ntohl(((uint32 *)svc->xdr->in_msg)[RPC_OFFSET+1]) != RPC_MSG_CALL) {
+        E("ERROR: expecting an RPC call on server channel!\n");
+        return;
+    }
+
+    if (prog != svc->x_prog) {
+        E("ERROR: prog num %08x does not match expected %08x!\n",
+          (unsigned)prog, (unsigned)svc->x_prog);
+        return;
+    }
+
+    if (vers != svc->xdr->x_vers) {
+        E("ERROR: prog vers %08x does not match expected %08x!\n",
+                vers, svc->xdr->x_vers);
+        return;
+    }
+
+    req.rq_prog = prog;
+    req.rq_vers = vers;
+    req.rq_proc = proc;
+    req.rq_xprt = xprt;
+
+    D("START: SVC DISPATCH %08x:%08x --> %08x\n",
+      (uint32_t)prog, (int)vers, proc);
+    /* The RPC header (XID, call type, RPC version, program number, program
+       version, proc number) is 6 long words; the default credentials are 4
+       long words.  This the offset (RPC_OFFSET + 10)<<2 is where the first
+       arguments start.
+    */
+    svc->xdr->in_next = (RPC_OFFSET + 6 + 4)*sizeof(uint32); 
+
+    svc->active = getpid();
+    svc->xdr->x_op = XDR_DECODE;
+    svc->dispatch(&req, (SVCXPRT *)svc);
+    svc->active = 0;
+    D("DONE: SVC DISPATCH %08x:%08x --> %08x\n",
+      (uint32_t)prog, (int)vers, proc);
+}
+
+void xprt_register(SVCXPRT *xprt)
+{
+    pthread_mutex_lock(&xprt_lock);
+    if (!the_xprt || (xprt && (xprt == the_xprt))) {
+        xprt_refcount++;
+        the_xprt = xprt;
+        D("registering RPC transport (refcount %d)\n", xprt_refcount);
+    }
+    else E("a different RPC transport has already been registered!\n");
+    pthread_mutex_unlock(&xprt_lock);
+}
+
+void xprt_unregister (SVCXPRT *xprt)
+{
+    pthread_mutex_lock(&xprt_lock);
+    if (xprt && xprt == the_xprt) {
+        if (xprt_refcount == 1) {
+            xprt_refcount = 0;
+            D("Destroying RPC transport (servers %d, cb servers %d)\n",
+              the_xprt->num_servers, the_xprt->num_cb_servers);
+
+            pthread_attr_destroy(&xprt->thread_attr);
+            pthread_mutexattr_destroy(&xprt->lock_attr);
+            pthread_mutex_destroy(&xprt->lock);
+            /* Make sure the thread has existed before we free the xprt
+               structure.  The thread is created as detached, so we do not wait
+               for it after we set the terminate flag in svc_unregister, but we
+               do have to wait for it to exit when we call svc_destroy.
+            */
+            pthread_join(xprt->svc_thread, NULL);
+            free(xprt);
+            the_xprt = NULL;
+        }
+        else xprt_refcount--;
+        D("unregistering RPC transport (refcount %d)\n", xprt_refcount);
+    }
+    else E("no RPC transport has been registered!\n");
+    pthread_mutex_unlock(&xprt_lock);
+}
+
+/* The functions that follow all take a pointer to the SVCXPRT instead of the
+   XDR of the server that they refer to.  The xprt pointer is actually a 
+   pointer to a registered_server, which identified the RPC server in
+   question.
+*/
+
+bool_t svc_getargs(SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) {
+        bool_t result = (bool_t) (*xdr_args)(serv->xdr, args_ptr);            
+        XDR_MSG_DONE (serv->xdr);
+        return result;
+    }
+    return FALSE;
+} /* svc_getargs */
+
+bool_t svc_freeargs (SVCXPRT * xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) { 
+        serv->xdr->x_op = XDR_FREE;
+        return (*xdr_args)((XDR *)serv->xdr, args_ptr);
+    }
+    return FALSE;
+}
+
+/* Send a reply to an rpc request */
+bool_t
+svc_sendreply (SVCXPRT *xprt, xdrproc_t xdr_results,
+               caddr_t xdr_location)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) { 
+        opaque_auth verf; 
+        verf.oa_flavor = AUTH_NONE;
+        verf.oa_length = 0;
+        
+        serv->xdr->x_op = XDR_ENCODE;
+        
+        if (!xdr_reply_msg_start(serv->xdr, &verf) ||
+            !xdr_results(serv->xdr, xdr_location)) 
+            return FALSE;
+
+        ((uint32 *)(serv->xdr->out_msg))[RPC_OFFSET] =
+            ((uint32 *)(serv->xdr->in_msg))[RPC_OFFSET]; //RPC xid
+        D("%08x:%d sending RPC reply (XID %d)\n",
+          serv->xdr->x_prog,
+          serv->xdr->x_vers,
+          ntohl(((uint32 *)(serv->xdr->out_msg))[RPC_OFFSET]));
+        XDR_MSG_SEND(serv->xdr);
+        return TRUE;
+    }
+    return FALSE;
+}
+
+/* Service error functions. */
+
+#define SVCERR_XDR_SEND(xdr, reply) \
+  ( XDR_MSG_START(xdr, RPC_MSG_REPLY) && \
+    xdr_send_reply_header(xdr, &reply) && \
+    XDR_MSG_SEND(xdr) )
+
+void svcerr_decode (SVCXPRT *xprt)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) { 
+        rpc_reply_header reply;
+        reply.stat = RPC_MSG_ACCEPTED;
+        reply.u.ar.verf = serv->xdr->verf;
+        reply.u.ar.stat = RPC_GARBAGE_ARGS;
+        
+        if (!SVCERR_XDR_SEND(serv->xdr, reply))
+            /* Couldn't send the reply - just give up */
+            XDR_MSG_ABORT(serv->xdr);
+    }
+} /* svcerr_decode */
+
+void svcerr_systemerr (SVCXPRT *xprt)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) { 
+        rpc_reply_header reply;
+        reply.stat = RPC_MSG_ACCEPTED;
+        reply.u.ar.verf = serv->xdr->verf;
+        reply.u.ar.stat = RPC_SYSTEM_ERR;
+        
+        if (!SVCERR_XDR_SEND(serv->xdr, reply))
+            /* Couldn't send the reply - just give up */
+            XDR_MSG_ABORT(serv->xdr);
+    }
+} /* svcerr_systemerr */
+
+void svcerr_noproc(SVCXPRT *xprt)
+{
+    registered_server *serv = (registered_server *)xprt;
+    if (serv->active) { 
+        rpc_reply_header reply;        
+        reply.stat = RPC_MSG_ACCEPTED;
+        reply.u.ar.verf = serv->xdr->verf;
+        reply.u.ar.stat = RPC_PROC_UNAVAIL;
+        
+        if (!SVCERR_XDR_SEND(serv->xdr, reply))
+            /* Couldn't send the reply - just give up */
+            XDR_MSG_ABORT(serv->xdr);        
+    }
+} /* svcerr_noproc */
diff --git a/librpc/svc_clnt_common.c b/librpc/svc_clnt_common.c
new file mode 100755
index 0000000..808cc6b
--- /dev/null
+++ b/librpc/svc_clnt_common.c
@@ -0,0 +1,324 @@
+#include <rpc/rpc.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <debug.h>
+
+extern int r_open(const char *router);
+extern void r_close(int handle);
+extern int r_read(int handle, char *buf, uint32 size);
+extern int r_write(int handle, const char *buf, uint32 size);
+extern int r_control(int handle, const uint32 cmd, void *arg);
+
+static void xdr_std_destroy(xdr_s_type *xdr)
+{
+    /* whatever */
+}
+
+static bool_t xdr_std_control(xdr_s_type *xdr, int request, void *info)
+{
+    return r_control(xdr->fd, request, info);
+}
+
+static bool_t xdr_std_msg_done(xdr_s_type *xdr)
+{
+    /* whatever */
+    return TRUE;
+}
+
+/* Outgoing message control functions */
+static bool_t xdr_std_msg_start(xdr_s_type *xdr, 
+                                 rpc_msg_e_type rpc_msg_type)
+{
+
+    /* xid is does not matter under our set of assumptions: that for a single
+     * program/version channel, communication is synchronous.  If several
+     * processes attempt to call functions on a program, then the rpcrouter
+     * driver will ensure that the calls are properly muxed, because the
+     * processes will have separate PIDs, and the rpcrouter driver uses PIDs to
+     * keep track of RPC transactions.  For multiple threads in the same
+     * process accessing the same program, we serialize access in clnt_call()
+     * by locking a mutex around the RPC call.  If threads in the same process
+     * call into different programs, then there is no issue, again because of
+     * the use of a mutex in clnt_call().
+     * 
+     * NOTE: This comment assumes that the only way we talk to the RPC router
+     *       from a client is by using clnt_call(), which is the case for all
+     *       client code generated by rpcgen().
+     *
+     * NOTE: The RPC router driver will soon be able to open a separate device
+     *       file for each program/version channel.  This will allow for
+     *       natural multiplexing among clients, as we won't have to rely on
+     *       the mutex for the case where different programs are being called
+     *       into by separate threads in the same process.  When this happens,
+     *       we'll need to optimize the RPC library to add a separate mutex for
+     *       each program/version channel, which will require some sort of
+     *       registry.
+     */
+
+    if (rpc_msg_type == RPC_MSG_CALL) xdr->xid++;
+
+    /* We start writing into the outgoing-message buffer at index 32, because
+       we need to write header information before we send the message.  The
+       header information includes the destination address and the pacmark
+       header.
+    */
+    xdr->out_next = (RPC_OFFSET+2)*sizeof(uint32);
+
+    /* we write the pacmark header when we send the message. */
+    ((uint32 *)xdr->out_msg)[RPC_OFFSET] = htonl(xdr->xid);
+    /* rpc call or reply? */
+    ((uint32 *)xdr->out_msg)[RPC_OFFSET+1] = htonl(rpc_msg_type);
+
+    return TRUE;
+}
+
+static bool_t xdr_std_msg_abort(xdr_s_type *xdr)
+{
+    /* dummy */
+    return TRUE;
+}
+
+/* Can be used to send both calls and replies. */
+
+extern bool_t xdr_recv_reply_header(xdr_s_type *xdr, rpc_reply_header *reply);
+
+#include <stdio.h>
+
+static bool_t xdr_std_msg_send(xdr_s_type *xdr)
+{  
+    /* Send the RPC packet. */
+    if (r_write(xdr->fd, (void *)xdr->out_msg, xdr->out_next) !=
+            xdr->out_next)
+        return FALSE;
+        
+    return TRUE;
+}
+
+static bool_t xdr_std_read(xdr_s_type *xdr)
+{
+    xdr->in_len = r_read(xdr->fd, (void *)xdr->in_msg, RPCROUTER_MSGSIZE_MAX);
+    if (xdr->in_len < 0) return FALSE;
+
+    if (xdr->in_len < (RPC_OFFSET+2)*4) {
+        xdr->in_len = -1;
+        return FALSE;
+    }
+
+    xdr->in_next = (RPC_OFFSET+2)*4;
+    return TRUE;
+}
+
+/* Message data functions */
+static bool_t xdr_std_send_uint32(xdr_s_type *xdr, const uint32 *value)
+{
+    if (xdr->out_next >= RPCROUTER_MSGSIZE_MAX - 3) return FALSE;
+    *(int32 *)(xdr->out_msg + xdr->out_next) = htonl(*value);
+    xdr->out_next += 4;
+    return TRUE;
+}
+
+static bool_t xdr_std_send_int8(xdr_s_type *xdr, const int8 *value)
+{
+    uint32 val = *value;
+    return xdr_std_send_uint32(xdr, &val);
+}
+
+static bool_t xdr_std_send_uint8(xdr_s_type *xdr, const uint8 *value)
+{
+    uint32 val = *value;
+    return xdr_std_send_uint32(xdr, &val);
+}
+
+static bool_t xdr_std_send_int16(xdr_s_type *xdr, const int16 *value)
+{
+    uint32 val = *value;
+    return xdr_std_send_uint32(xdr, &val);
+}
+
+static bool_t xdr_std_send_uint16(xdr_s_type *xdr, const uint16 *value)
+{
+    uint32 val = *value;
+    return xdr_std_send_uint32(xdr, &val);
+}
+
+static bool_t xdr_std_send_int32(xdr_s_type *xdr, const int32 *value)
+{
+    return xdr_std_send_uint32(xdr, (uint32_t *)value);
+}
+
+static bool_t xdr_std_send_bytes(xdr_s_type *xdr, const uint8 *buf, 
+                                   uint32 len)
+{
+    if (xdr->out_next + len > RPCROUTER_MSGSIZE_MAX) return FALSE; 
+    while(len--)
+        xdr->out_msg[xdr->out_next++] = *buf++;
+    while(xdr->out_next % 4)
+        xdr->out_msg[xdr->out_next++] = 0;
+    return TRUE;
+}
+
+#if 0
+#include <unwind.h> 
+typedef struct
+{
+    size_t count;
+    intptr_t* addrs;
+} stack_crawl_state_t;
+
+static _Unwind_Reason_Code trace_function(_Unwind_Context *context, void *arg)
+{
+    stack_crawl_state_t* state = (stack_crawl_state_t*)arg;
+    if (state->count) {
+        intptr_t ip = (intptr_t)_Unwind_GetIP(context);
+        if (ip) {
+            state->addrs[0] = ip;
+            state->addrs++;
+            state->count--;
+        }
+    }
+    return _URC_NO_REASON;
+}
+
+static inline
+int get_backtrace(intptr_t* addrs, size_t max_entries)
+{
+    stack_crawl_state_t state;
+    state.count = max_entries;
+    state.addrs = (intptr_t*)addrs;
+    _Unwind_Backtrace(trace_function, (void*)&state);
+    return max_entries - state.count;
+}
+#endif
+
+static bool_t xdr_std_recv_uint32(xdr_s_type *xdr, uint32 *value)
+{
+#if 0
+    intptr_t *trace[20], *tr;
+    int nc = get_backtrace(trace, 20);
+    tr = trace;
+    while(nc--)
+        D("\t%02d: %p\n", nc, *tr++);
+#endif
+        
+    if (xdr->in_next + 4 > xdr->in_len) { return FALSE; }
+    if (value) *value = ntohl(*(uint32 *)(xdr->in_msg + xdr->in_next));
+    xdr->in_next += 4;
+    return TRUE;
+}
+
+#define RECEIVE                                 \
+    uint32 val;                                 \
+    if (xdr_std_recv_uint32(xdr, &val)) {       \
+        *value = val;                           \
+        return TRUE;                            \
+    }                                           \
+    return FALSE
+
+static bool_t xdr_std_recv_int8(xdr_s_type *xdr, int8 *value)
+{
+    RECEIVE;
+}
+
+static bool_t xdr_std_recv_uint8(xdr_s_type *xdr, uint8 *value)
+{
+    RECEIVE;
+}
+
+static bool_t xdr_std_recv_int16(xdr_s_type *xdr, int16 *value)
+{
+    RECEIVE;
+}
+
+static bool_t xdr_std_recv_uint16(xdr_s_type *xdr, uint16 *value)
+{
+    RECEIVE;
+}
+
+#undef RECEIVE
+
+static bool_t xdr_std_recv_int32(xdr_s_type *xdr, int32 *value)
+{
+    return xdr_std_recv_uint32(xdr, (uint32 * )value);
+}
+
+static bool_t xdr_std_recv_bytes(xdr_s_type *xdr, uint8 *buf, uint32 len)
+{
+    if (xdr->in_next + (int)len > xdr->in_len) return FALSE;     
+    if (buf) memcpy(buf, &xdr->in_msg[xdr->in_next], len);
+    xdr->in_next += len;
+    xdr->in_next = (xdr->in_next + 3) & ~3;
+    return TRUE;
+}
+
+const xdr_ops_s_type xdr_std_xops = {
+
+    xdr_std_destroy,
+    xdr_std_control,
+    xdr_std_read,
+    xdr_std_msg_done,
+    xdr_std_msg_start,
+    xdr_std_msg_abort,
+    xdr_std_msg_send,
+
+    xdr_std_send_int8,
+    xdr_std_send_uint8,
+    xdr_std_send_int16,
+    xdr_std_send_uint16,
+    xdr_std_send_int32,
+    xdr_std_send_uint32,
+    xdr_std_send_bytes,
+    xdr_std_recv_int8,
+    xdr_std_recv_uint8,
+    xdr_std_recv_int16,
+    xdr_std_recv_uint16,
+    xdr_std_recv_int32,
+    xdr_std_recv_uint32,
+    xdr_std_recv_bytes,
+};
+
+xdr_s_type *xdr_init_common(const char *router, int is_client)
+{
+    xdr_s_type *xdr = (xdr_s_type *)calloc(1, sizeof(xdr_s_type)); 
+
+    xdr->xops = &xdr_std_xops;
+
+    xdr->fd = r_open(router);
+    if (xdr->fd < 0) {
+        E("ERROR OPENING [%s]: %s\n", router, strerror(errno));
+        free(xdr);
+        return NULL;
+    }
+    xdr->is_client = is_client;
+
+    D("OPENED [%s] fd %d\n", router, xdr->fd);
+    return xdr;
+}
+
+xdr_s_type *xdr_clone(xdr_s_type *other)
+{
+    xdr_s_type *xdr = (xdr_s_type *)calloc(1, sizeof(xdr_s_type)); 
+
+    xdr->xops = &xdr_std_xops;
+
+    xdr->fd = dup(other->fd);
+    if (xdr->fd < 0) {
+        E("ERROR DUPLICATING FD %d: %s\n", other->fd, strerror(errno));
+        free(xdr);
+        return NULL;
+    }
+
+    xdr->xid = xdr->xid;
+    xdr->x_prog = other->x_prog;
+    xdr->x_vers = other->x_vers;
+    xdr->is_client = other->is_client;
+
+    D("CLONED fd %d --> %d\n", other->fd, xdr->fd);
+    return xdr;
+}
+
+void xdr_destroy_common(xdr_s_type *xdr)
+{
+    D("CLOSING fd %d\n", xdr->fd);
+    r_close(xdr->fd);
+    free(xdr);
+}
diff --git a/librpc/xdr.c b/librpc/xdr.c
new file mode 100755
index 0000000..c91664b
--- /dev/null
+++ b/librpc/xdr.c
@@ -0,0 +1,528 @@
+#include <rpc/rpc.h>
+#include <string.h>
+
+#define LASTUNSIGNED    ((u_int)((int)0-1))
+
+/* 
+ * Primitives for stuffing data into and retrieving data from an XDR 
+ */
+
+bool_t xdr_bytes (XDR *xdr, char **cpp, u_int *sizep, u_int maxsize)
+{
+    switch(xdr->x_op) {
+    case XDR_DECODE:
+        if(!XDR_RECV_UINT(xdr, sizep) || *sizep > maxsize)
+            return FALSE;        
+        if(*sizep == 0)
+            return TRUE;        
+        if(*cpp == NULL)
+            *cpp = (char *) mem_alloc(*sizep);
+        if(*cpp == NULL) return FALSE;
+        return XDR_RECV_BYTES(xdr, (uint8 *) *cpp, *sizep);        
+    case XDR_ENCODE:
+        return (XDR_SEND_UINT(xdr, sizep) &&
+                *sizep <= maxsize &&
+                XDR_SEND_BYTES(xdr, (uint8 *) *cpp, *sizep));        
+    case XDR_FREE:
+        if (*cpp) {
+            mem_free(*cpp);
+            *cpp = NULL;
+        }
+        return TRUE;        
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_bytes */
+
+bool_t xdr_send_enum (xdr_s_type *xdr, const void *value, uint32 size)
+{
+    switch (size) {
+    case 4:
+        return XDR_SEND_INT32(xdr, (int32 *) value);
+    case 2:
+        return XDR_SEND_INT16(xdr, (int16 *) value);
+    case 1:
+        return XDR_SEND_INT8(xdr, (int8 *) value);
+    default:
+        return FALSE;
+    }
+} /* xdr_send_enum */
+
+bool_t xdr_recv_enum (xdr_s_type *xdr, void *value, uint32 size)
+{
+    switch (size) {
+    case 4:
+        return XDR_RECV_INT32(xdr, (int32 *) value);
+    case 2:
+        return XDR_RECV_INT16(xdr, (int16 *) value);
+    case 1:
+        return XDR_RECV_INT8(xdr, (int8 *) value);
+    default:
+        return FALSE;
+    }
+} /* xdr_recv_enum */
+
+#include <stdio.h>
+
+bool_t xdr_enum (XDR *xdr, enum_t *ep)
+{
+    switch(xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_INT32(xdr, (int32 *)ep);  
+    case XDR_DECODE:
+        return XDR_RECV_INT32(xdr, (int32 *)ep);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_enum */
+
+bool_t xdr_u_int (XDR *xdr, u_int *uip)
+{
+    switch(xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_UINT32(xdr, (uint32 *) uip);
+    case XDR_DECODE:
+        return XDR_RECV_UINT32(xdr, (uint32 *) uip);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_u_int */
+
+bool_t xdr_u_char (XDR *xdr, u_char *cp)
+{
+    u_int u = (*cp);
+    if (!xdr_u_int (xdr, &u))
+        return FALSE;
+    *cp = (u_char) u;
+    return TRUE;
+} /* xdr_u_char */
+
+bool_t xdr_long (XDR *xdr, long *lp)
+{
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_INT32(xdr, (int32_t *)lp);
+    case XDR_DECODE:
+        return XDR_RECV_INT32(xdr, (int32_t *)lp);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_long */
+
+bool_t xdr_u_long (XDR *xdr, u_long *ulp)
+{
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_UINT32(xdr, (uint32_t *)ulp);
+    case XDR_DECODE:
+        return XDR_RECV_UINT32(xdr, (uint32_t *)ulp);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_u_long */
+
+/*
+ * XDR hyper integers
+ * same as xdr_hyper - open coded to save a proc call!
+ */
+bool_t xdr_u_hyper (XDR *xdrs, u_quad_t *ullp)
+{
+    unsigned long t1;
+    unsigned long t2;
+    
+    if (xdrs->x_op == XDR_ENCODE) {
+        t1 = (unsigned long) ((*ullp) >> 32);
+        t2 = (unsigned long) (*ullp);
+        return (XDR_SEND_INT32(xdrs, (int32 *)&t1) &&
+                XDR_SEND_INT32(xdrs, (int32 *)&t2));
+    }
+
+    if (xdrs->x_op == XDR_DECODE) {
+        if (!XDR_RECV_INT32(xdrs, (int32 *)&t1) ||
+            !XDR_RECV_INT32(xdrs, (int32 *)&t2))
+            return FALSE;
+        *ullp = ((u_quad_t) t1) << 32;
+        *ullp |= t2;
+        return TRUE;
+    }
+    
+    return xdrs->x_op == XDR_FREE;
+}
+
+bool_t
+xdr_u_quad_t (XDR *xdrs, u_quad_t *ullp)
+{
+    return xdr_u_hyper(xdrs, ullp);
+}
+
+bool_t xdr_u_short (XDR *xdr, u_short *usp)
+{
+    u_long l;
+
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        l = *usp;
+        return XDR_SEND_UINT32(xdr, (uint32_t *)&l);
+    case XDR_DECODE:
+        if(!XDR_RECV_UINT32(xdr, (uint32_t *)&l))
+            return FALSE;
+        *usp = (u_short)l;
+        return TRUE;
+    case XDR_FREE:
+        return TRUE;      
+    default:
+        break;
+    }
+
+    return FALSE;
+} /* xdr_u_short */
+
+/*
+ * xdr_vector():
+ *
+ * XDR a fixed length array. Unlike variable-length arrays,
+ * the storage of fixed length arrays is static and unfreeable.
+ * > basep: base of the array
+ * > size: size of the array
+ * > elemsize: size of each element
+ * > xdr_elem: routine to XDR each element
+ */
+bool_t
+xdr_vector (XDR *xdrs,
+            char *basep,
+            u_int nelem,
+            u_int elemsize,
+            xdrproc_t xdr_elem)
+{
+    u_int i;
+    char *elptr;
+    
+    elptr = basep;
+    for (i = 0; i < nelem; i++) {
+        if (!(*xdr_elem) (xdrs, elptr, LASTUNSIGNED))
+            return FALSE;
+        elptr += elemsize;
+    }
+    return TRUE;
+}
+
+bool_t xdr_bool (XDR *xdr, bool_t *bp)
+{
+    uint32 lb;
+    
+    switch(xdr->x_op) {
+    case XDR_ENCODE:
+        lb = *bp ? TRUE : FALSE;
+        return XDR_SEND_UINT32(xdr, &lb);
+    case XDR_DECODE:
+        if (!XDR_RECV_UINT32(xdr, &lb))
+            return FALSE;
+        *bp = (lb == FALSE) ? FALSE : TRUE;
+        return TRUE;
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    
+    return FALSE;
+} /* xdr_bool */
+
+/*
+ * XDR an indirect pointer
+ * xdr_reference is for recursively translating a structure that is
+ * referenced by a pointer inside the structure that is currently being
+ * translated.  pp references a pointer to storage. If *pp is null
+ * the  necessary storage is allocated.
+ * size is the size of the referneced structure.
+ * proc is the routine to handle the referenced structure.
+ */
+bool_t
+xdr_reference (XDR *xdrs,
+               caddr_t *pp,     /* the pointer to work on */
+               u_int size,      /* size of the object pointed to */
+               xdrproc_t proc)   /* xdr routine to handle the object */
+{
+    bool_t stat;
+    
+    if (*pp == NULL) {
+        switch (xdrs->x_op) {
+        case XDR_FREE:
+            return TRUE;
+            
+        case XDR_DECODE:
+            *pp = (caddr_t) mem_alloc (size);
+            if (*pp == NULL) return FALSE;
+            memset(*pp, 0, size);
+            break;
+        default:
+            break;
+        }
+    }
+
+    stat = (*proc) (xdrs, *pp, LASTUNSIGNED);
+    
+    if (xdrs->x_op == XDR_FREE) {
+        mem_free(*pp);
+        *pp = NULL;
+    }
+    return stat;
+} /* xdr_reference */
+
+/*
+ * xdr_pointer():
+ *
+ * XDR a pointer to a possibly recursive data structure. This
+ * differs with xdr_reference in that it can serialize/deserialize
+ * trees correctly.
+ *
+ *  What's sent is actually a union:
+ *
+ *  union object_pointer switch (bool_t b) {
+ *  case TRUE: object_data data;
+ *  case FALSE: void nothing;
+ *  }
+ *
+ * > objpp: Pointer to the pointer to the object.
+ * > obj_size: size of the object.
+ * > xdr_obj: routine to XDR an object.
+ *
+ */
+
+bool_t
+xdr_pointer (XDR *xdrs,
+             char **objpp,
+             u_int obj_size,
+             xdrproc_t xdr_obj)
+{
+    bool_t more_data;
+    
+    more_data = (*objpp != NULL);
+    if (!xdr_bool (xdrs, &more_data))
+        return FALSE;
+    
+    if (!more_data) {
+        *objpp = NULL;
+        return TRUE;
+    }
+    return xdr_reference (xdrs, objpp, obj_size, xdr_obj);
+} /* xdr_pointer */
+
+bool_t xdr_void (void)
+{
+    return TRUE;
+} /* xdr_void */
+
+/*
+ * XDR an array of arbitrary elements
+ * *addrp is a pointer to the array, *sizep is the number of elements.
+ * If addrp is NULL (*sizep * elsize) bytes are allocated.
+ * elsize is the size (in bytes) of each element, and elproc is the
+ * xdr procedure to call to handle each element of the array.
+ */
+bool_t
+xdr_array (XDR *xdrs,
+           caddr_t *addrp,/* array pointer */
+           u_int *sizep,  /* number of elements */
+           u_int maxsize,  /* max numberof elements */
+           u_int elsize,  /* size in bytes of each element */
+           xdrproc_t elproc) /* xdr routine to handle each element */
+{
+    u_int i;
+    caddr_t target = *addrp;
+    u_int c;/* the actual element count */
+    bool_t stat = TRUE;
+    u_int nodesize;
+
+    /* like strings, arrays are really counted arrays */
+    if (!xdr_u_int (xdrs, sizep))
+        return FALSE;
+    c = *sizep;
+    if ((c > maxsize) && (xdrs->x_op != XDR_FREE))
+        return FALSE;
+    nodesize = c * elsize;
+
+    /*
+     * if we are deserializing, we may need to allocate an array.
+     * We also save time by checking for a null array if we are freeing.
+     */
+    if (target == NULL)
+        switch (xdrs->x_op) {
+        case XDR_DECODE:
+            if (c == 0)
+                return TRUE;
+            *addrp = target = mem_alloc (nodesize);
+            if (!*addrp) return FALSE;
+            memset (target, 0, nodesize);
+            break;            
+        case XDR_FREE:
+            return TRUE;
+        default:
+            break;
+        }
+    
+    /*
+     * now we xdr each element of array
+     */
+    for (i = 0; (i < c) && stat; i++) {
+        stat = (*elproc) (xdrs, target, LASTUNSIGNED);
+        target += elsize;
+    }
+
+    /*
+     * the array may need freeing
+     */
+    if (xdrs->x_op == XDR_FREE) {
+        mem_free(*addrp);
+        *addrp = NULL;
+    }
+
+    return stat;
+}
+
+bool_t xdr_int(XDR *xdr, int *ip)
+{
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_INT32(xdr, (int32 *) ip);
+    case XDR_DECODE:
+        return XDR_RECV_INT32(xdr, (int32 *) ip);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+
+    return FALSE;
+} /* xdr_int */
+
+bool_t xdr_opaque (XDR *xdr, caddr_t cp, u_int cnt)
+{
+    /* if no data we are done */
+    if (cnt == 0)
+        return TRUE;
+
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        return XDR_SEND_BYTES(xdr, (uint8 *) cp, cnt);
+    case XDR_DECODE:
+        return XDR_RECV_BYTES(xdr, (uint8 *) cp, cnt);
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+
+    return FALSE;
+} /* xdr_opaque */
+
+bool_t xdr_char (XDR *xdr, char *cp)
+{
+    int i;
+    i = (*cp);
+    if (!xdr_int (xdr, &i))
+        return FALSE;
+    *cp = i;
+    return TRUE;
+} /* xdr_char */
+
+bool_t
+xdr_quad_t (XDR *xdrs, quad_t *llp)
+{
+    return xdr_u_quad_t(xdrs, (u_quad_t *)llp);
+}
+
+bool_t xdr_short (XDR *xdr, short *sp)
+{
+    long l;
+    switch (xdr->x_op) {
+    case XDR_ENCODE:
+        l = *sp;
+        return XDR_SEND_INT32(xdr, (int32_t *)&l);
+    case XDR_DECODE:
+        if (!XDR_RECV_INT32(xdr, (int32_t *)&l))
+            return FALSE;
+        *sp = (short)l;
+        return TRUE;
+    case XDR_FREE:
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_short */
+
+/*
+ * Non-portable xdr primitives.
+ * Care should be taken when moving these routines to new architectures.
+ */
+
+/*
+ * XDR null terminated ASCII strings
+ * xdr_string deals with "C strings" - arrays of bytes that are
+ * terminated by a NULL character.  The parameter cpp references a
+ * pointer to storage; If the pointer is null, then the necessary
+ * storage is allocated.  The last parameter is the max allowed length
+ * of the string as specified by a protocol.
+ */
+bool_t xdr_string (XDR *xdr, char **cpp, u_int maxsize)
+{
+    u_int size;
+    u_int nodesize;
+
+    /*
+     * first deal with the length since xdr strings are counted-strings
+     */
+    switch (xdr->x_op) {
+    case XDR_FREE:
+        if (*cpp == NULL) return TRUE;
+        /* fall through... */
+    case XDR_ENCODE:
+        if (*cpp == NULL) return FALSE;
+        size = strlen(*cpp);
+        break;
+    case XDR_DECODE:
+        break;
+    default:
+        break;
+    }
+
+    if (!xdr_u_int(xdr, &size)) return FALSE;
+    if (size > maxsize) return FALSE;
+    nodesize = size + 1;
+
+    /*
+     * now deal with the actual bytes
+     */
+    switch (xdr->x_op) {
+    case XDR_DECODE:
+        if (nodesize == 0) return TRUE;
+        if (*cpp == NULL)
+            *cpp = (char *)mem_alloc(nodesize);
+        if (*cpp == NULL) return FALSE;
+        (*cpp)[size] = 0;
+        /* fall through... */
+    case XDR_ENCODE:
+        return xdr_opaque(xdr, *cpp, size);
+    case XDR_FREE:
+        mem_free(*cpp);
+        *cpp = NULL;
+        return TRUE;
+    default:
+        break;
+    }
+    return FALSE;
+} /* xdr_string */
diff --git a/libstagefrighthw/msm7x30/Android.mk b/libstagefrighthw/msm7x30/Android.mk
index fe741f8..d4ac909 100644
--- a/libstagefrighthw/msm7x30/Android.mk
+++ b/libstagefrighthw/msm7x30/Android.mk
@@ -17,6 +17,9 @@
 ifeq ($(TARGET_BOARD_PLATFORM),msm7x30)
 
 LOCAL_PATH := $(call my-dir)
+
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
@@ -39,3 +42,5 @@ LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
 
 endif
+
+endif
diff --git a/libstagefrighthw/msm8x60/Android.mk b/libstagefrighthw/msm8x60/Android.mk
index 8080536..6643757 100644
--- a/libstagefrighthw/msm8x60/Android.mk
+++ b/libstagefrighthw/msm8x60/Android.mk
@@ -16,6 +16,9 @@
 
 ifeq ($(TARGET_BOARD_PLATFORM),msm8660)
 LOCAL_PATH := $(call my-dir)
+
+ifneq ($(BOARD_USES_QCOM_LEGACY),true)
+
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
@@ -36,4 +39,7 @@ LOCAL_SHARED_LIBRARIES :=       \
 LOCAL_MODULE := libstagefrighthw
 LOCAL_MODULE_TAGS := optional
 include $(BUILD_SHARED_LIBRARY)
+
+endif
+
 endif
